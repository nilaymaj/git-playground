{"version":3,"sources":["../node_modules/yargs-parser/build/lib sync","simulator/utils/errors.ts","simulator/utils/tree.ts","simulator/utils/path-utils.ts","simulator/file-system/index.ts","simulator/constants.ts","simulator/git-repository/head/index.ts","simulator/git-repository/object-storage/hash-object.ts","simulator/git-repository/object-storage/utils.ts","simulator/utils/sorted-array.ts","simulator/git-repository/index-file/create-index-tree.ts","simulator/git-repository/index-file/index.ts","simulator/git-repository/object-storage/index.ts","simulator/git-repository/ref-storage/index.ts","simulator/git-repository/index.ts","simulator/index.ts","app/mainframe/providers/sandbox-provider.tsx","app/panes/pane.tsx","app/ui/empty-prompt.tsx","app/panes/files-manager/directory-item.tsx","app/panes/files-manager/file-item.tsx","app/panes/files-manager/directory-children.tsx","app/panes/files-manager/file-system-view.tsx","app/panes/files-manager/index.tsx","app/ui/monospace-chip.tsx","app/panes/index-file-view/index-item-row.tsx","app/panes/index-file-view/index.tsx","app/panes/object-storage-view/object-row.tsx","app/panes/object-storage-view/index.tsx","app/panes/repository-viewer/index.tsx","app/panes/staging-area/index.tsx","simulator/operations/utils.ts","simulator/operations/file-system/cp.ts","simulator/operations/file-system/create.ts","simulator/operations/file-system/edit.ts","simulator/operations/file-system/mkdir.ts","simulator/operations/file-system/mv.ts","simulator/operations/file-system/rm.ts","simulator/operations/git-repository/add.ts","simulator/operations/git-repository/checkout.ts","simulator/operations/git-repository/commit.ts","simulator/operations/git-repository/reset.ts","simulator/terminal/parser.ts","simulator/terminal/index.ts","app/panes/terminal/terminal.ts","app/panes/terminal/terminal-row.tsx","app/panes/terminal/terminal-data.tsx","app/panes/terminal/terminal-input.tsx","app/panes/terminal/index.tsx","app/mainframe/layouts.ts","app/mainframe/index.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","InvalidArgError","message","Object","setPrototypeOf","prototype","Apocalypse","Tree","tree","_tree","clone","updatedClass","get","path","length","getIn","insert","node","parentNode","slice","isInternalNode","nodeName","has","nodeToInsert","undefined","OrderedMap","newTree","setIn","remove","deleteIn","update","value","updateIn","convert","map","convertNode","isLeafNode","toLeafArray","compareNames","basePath","treeToLeafs","this","treeChildren","entries","sort","a","b","flatMap","name","isPrefix","fullPath","prefix","i","parsePathString","pathString","trim","split","getPathString","join","getParentPath","FileSystem","fs","_fs","newFS","getPathDepth","parent","isFile","create","type","item","generateFileBlob","delete","isDirectory","bumpFileVersion","file","newFile","version","move","srcPath","destPath","preserveSrc","destDirPath","destDir","fsWithoutDest","destItem","fsWithDest","token","contentToken","uuid","DEFAULT_BRANCH_NAME","CreateGitHead","Record","isDetached","destination","GitHead","head","_head","newHead","commitAddr","set","branchPath","target","targetIsRef","Array","isArray","refStorage","commitHash","detachTo","branchName","readLeaf","HASH_METHOD","hashBlobObject","blob","fileData","finalToken","toString","createHash","digest","hashTreeObject","from","items","reduce","currentHash","itemString","hashCommitObject","commit","hasher","workTree","timestamp","toISOString","serializeGitTree","storage","mainNode","child","childName","hash","subNode","read","serializedSubTree","SortedArray","compareFn","isSorted","_items","_compareFn","newItems","key","argKey","lowIndex","highIndex","size","midIndex","Math","floor","compared","index","itemAt","newItem","upsert","itemKey","newValue","findRange","searchFn","start","end","startIndex","endIndex","freeze","itemsList","List","result","createIndexTree","filePaths","getRootNameChunks","rootNode","chunk","indexEntry","_index","subIndexItems","subIndex","IndexFile","subIndexTree","fullPaths","chunks","currentStart","currentName","itemName","push","localeCompare","comparePaths","nameCmp","newIndex","entry","toTree","getPathSection","entryPath","overwriteSection","sectionLimits","itemBeforeSplit","firstSubItem","itemAfterSplit","lastSubItem","preSection","postSection","newIndexRawItems","fromFileTree","fileTree","objectStorage","fileTreeLeaves","newStorage","indexEntries","leaf","gitBlob","write","objS","objectHash","indexFile","fromGitTree","ObjectStorage","db","_db","object","hashObject","newDB","Map","defaultBranchHeads","RefStorage","branchHeads","_branchHeads","newBranchHeads","refNode","isLeaf","newRefTree","getChildren","createNewSandbox","fileSystem","repository","sampleSandbox","SandboxContext","React","setSandbox","SandboxProvider","props","sandbox","sandboxManager","Provider","children","useRepository","Pane","paneClass","clsx","className","style","borderColor","accentColor","title","backgroundColor","EmptyPrompt","color","SingleDirectoryItem","onClick","onToggleExpand","expanded","DirectoryItem","setExpanded","collapsed","directory","FileItem","fileInfo","DirectoryChildren","classes","collapse","childNode","FileSystemView","isEmptyFS","FileSystemPane","MonospaceChip","hint","text","IndexItemRow","shortHash","indexItem","navigator","clipboard","writeText","IndexFileView","indexItems","isEmptyIndex","getDisplayString","shortContentToken","fileVersion","numChildren","commitMessage","ObjectRow","ObjectStorageView","objects","isEmpty","RepositoryViewerPane","JSON","stringify","StagingAreaPane","errorState","system","success","successState","validateSource","print","noDirectory","srcPathDepth","copyItems","paths","opts","srcPaths","multiSrc","recursive","ensureDir","destPathDepth","validateDest","currentFS","srcItemName","destNode","fullDest","destPathStr","srcPathStr","cpCommand","options","shortLetter","description","valueType","execute","args","createFile","parentPath","createCommand","_opts","editCommand","mkdirCommand","moveItems","mvCommand","rmCommand","gitAddCommand","currentIndex","currentObjectStorage","fsItem","indexSection","gitCheckoutCommand","parseArgs","commitObject","gitTreeAddress","gitWorkTree","serializedTree","newFileSystem","newIndexFile","createWorkTreeFromIndex","indexTree","treeItems","currentStorage","gitTree","gitCommitCommand","_args","tempStorage","treeHash","parentCommit","getTargetCommit","Date","advanceTo","newRefStorage","gitResetCommand","soft","mixed","hard","targetCommitHash","resetMode","getResetMode","gb","Parser","binPath","parse","input","commandName","find","cmdName","cmdNamePrefix","indexOf","argSubstring","commandOptions","yargsOpts","createYargsOptions","parsed","yargsParse","_","command","cmdOptions","yOpts","string","boolean","alias","forEach","optionName","option","PATH","CreateCommand","edit","EditCommand","mkdir","MkdirCommand","rm","RmCommand","cp","CpCommand","mv","MvCommand","GitAddCommand","GitCheckoutCommand","GitCommitCommand","GitResetCommand","startTerminal","TerminalRow","prompt","TerminalData","containerRef","container","current","scrollTop","scrollHeight","data","ref","r","idx","dataLine","TerminalInput","setInput","onInput","handler","event","trimmedInput","document","addEventListener","removeEventListener","onChange","terminalObj","parser","commandUsed","TerminalPane","terminalRef","terminalHistory","setTerminalHistory","terminal","oldHistory","newSystem","h","terminalLines","pushOutput","multitaskerLayout","direction","splitPercentage","first","second","ELEMENT_MAP","Mainframe","renderTile","initialValue","App","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.408ad362.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 338;","/**\n * Represents an error originating from an invalid path\n * being provided to a function or command.\n */\nexport class InvalidArgError extends Error {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, InvalidArgError.prototype);\n  }\n}\n\n/**\n * Represents an error originating from something that just\n * shouldn't happen, something terribly wrong.\n */\nexport class Apocalypse extends Error {\n  constructor(message?: string) {\n    super(message);\n    Object.setPrototypeOf(this, Apocalypse.prototype);\n  }\n}\n","import { OrderedMap } from 'immutable';\nimport { InvalidArgError } from './errors';\n\n/**\n * An internal node of the tree, containing\n * named references to children\n */\nexport type TreeInternalNode<L, N> = OrderedMap<N, TreeNode<L, N>>;\n\n/**\n * A general node of the tree. May be internal or leaf node.\n */\nexport type TreeNode<L, N> = L | TreeInternalNode<L, N>;\n\n/**\n * Path to an item in the tree. Elements\n * are segment names in the path.\n */\nexport type TreePath<N> = N[];\n\n/**\n * Immutable data structure for representing a tree\n * with data stored at the leaves. Each branch of every\n * internal node has a name.\n * - L: the type of data stored at leaf node\n * - N: the type of branch names in internal nodes\n */\nexport default class Tree<L, N> {\n  _tree: TreeInternalNode<L, N>;\n\n  /**\n   * Create a new Tree, optionally with the given\n   * ImmutableJS OrderedMap tree representation.\n   */\n  constructor(tree?: TreeInternalNode<L, N>) {\n    if (!tree) this._tree = OrderedMap<N, TreeNode<L, N>>();\n    else this._tree = tree;\n  }\n\n  /**\n   * Creates a clone of this tree.\n   */\n  clone = (tree: Tree<L, N>) => {\n    return new Tree(tree._tree);\n  };\n\n  /**\n   * Check if the given node is an internal node of a Tree.\n   * Returns `false` if the given node is `null`.\n   */\n  static isInternalNode = <L, N>(\n    node: TreeNode<L, N> | null\n  ): node is TreeInternalNode<L, N> => {\n    if (!node) return false;\n    return node instanceof OrderedMap;\n  };\n\n  /**\n   * Check if the given node is a leaf node of a Tree.\n   * Returns `false` if the given node is `null`.\n   */\n  static isLeafNode = <L, N>(node: TreeNode<L, N> | null): node is L => {\n    if (!node) return false;\n    return !(node instanceof OrderedMap);\n  };\n\n  /**\n   * Immutability helper method: use this to return a new\n   * Tree class with the updated underlying tree data.\n   */\n  private updatedClass = (tree: TreeInternalNode<L, N>) => {\n    if (this._tree === tree) return this;\n    else return new Tree(tree);\n  };\n\n  /**\n   * Get the node located at specified path in the tree.\n   * Returns `null` if the path does not exist.\n   */\n  get = (path: TreePath<N>): TreeNode<L, N> | null => {\n    if (path.length === 0) return this._tree;\n    return this._tree.getIn(path, null);\n  };\n\n  /**\n   * Insert a new node at the specified path in the tree.\n   * If node is not provided, creates an empty subtree at the path.\n   * Does not create any intermediate directories.\n   *\n   * Throws error if the path is invalid or node already exists.\n   */\n  insert = (path: TreePath<N>, node?: TreeNode<L, N>): Tree<L, N> => {\n    if (path.length === 0) throw new InvalidArgError();\n    // Check if parent node is valid\n    const parentNode = this.get(path.slice(0, -1));\n    if (!Tree.isInternalNode(parentNode)) throw new InvalidArgError();\n    // Check if node already exists at path\n    const nodeName = path[path.length - 1];\n    if (parentNode.has(nodeName)) throw new Error('Node already exists');\n    // Insert node and return new tree\n    const nodeToInsert = node === undefined ? OrderedMap() : node;\n    const newTree = this._tree.setIn(path, nodeToInsert);\n    return this.updatedClass(newTree);\n  };\n\n  /**\n   * Remove the leaf or subtree located at specified path in the tree.\n   *\n   * Throws if path is empty or does not exist.\n   */\n  remove = (path: TreePath<N>): Tree<L, N> => {\n    if (path.length === 0) throw new InvalidArgError();\n    if (!this.get(path)) throw new InvalidArgError();\n    const newTree = this._tree.deleteIn(path);\n    return this.updatedClass(newTree);\n  };\n\n  /**\n   * Update the node at the specified path to provided value.\n   * The value can be leaf data or a subtree.\n   *\n   * Throws if the path is invalid or the node does not exist.\n   */\n  update = (path: TreePath<N>, value: TreeNode<L, N>): Tree<L, N> => {\n    if (path.length === 0) throw new InvalidArgError();\n    const node = this.get(path);\n    if (node === null) throw new InvalidArgError();\n    const newTree = this._tree.updateIn(path, null, () => value);\n    return this.updatedClass(newTree);\n  };\n\n  /**\n   * Runs provided converter function on each leaf, to return\n   * a new Tree with the same structure but converted leaf data.\n   */\n  convert = <Ld>(convert: (leaf: L) => Ld): Tree<Ld, N> => {\n    const convertNode = (node: TreeNode<L, N>): TreeNode<Ld, N> => {\n      if (Tree.isLeafNode(node)) return convert(node);\n      else return node.map(convertNode);\n    };\n\n    const newTree = this._tree.map(convertNode);\n    return new Tree(newTree);\n  };\n\n  /**\n   * Serializes the tree into an array of its leaves.\n   * If `compareNames` is provided, sorts the leaves by path.\n   */\n  toLeafArray = (\n    compareNames?: (a: N, b: N) => number,\n    basePath: TreePath<N> = []\n  ): { path: TreePath<N>; value: L }[] => {\n    return Tree.treeToLeafs(this._tree, basePath, compareNames);\n  };\n\n  /**\n   * Serialize an Immutable.JS tree into array of leaves.\n   * `basePath` is prefixed to the path of every leaf.\n   */\n  private static treeToLeafs = <L, N>(\n    tree: TreeNode<L, N>,\n    basePath: TreePath<N>,\n    compareNames?: (a: N, b: N) => number\n  ): { path: TreePath<N>; value: L }[] => {\n    // Leaf nodes serialize to a single leaf\n    if (Tree.isLeafNode(tree)) return [{ path: basePath, value: tree }];\n    // Get (and optionally sort) direct children of node\n    const treeChildren = [...tree.entries()];\n    if (compareNames) treeChildren.sort((a, b) => compareNames(a[0], b[0]));\n    // Recursively serialize subtrees and pack them together\n    return treeChildren.flatMap(([name, node]) =>\n      Tree.treeToLeafs(node, [...basePath, name], compareNames)\n    );\n  };\n}\n","import { FileSystemPath } from '../file-system';\n\n/**\n * Checks if a path is a prefix of another path, including if both\n * paths are identical. Returns `true` if is prefix.\n */\nexport const isPrefix = (fullPath: FileSystemPath, prefix: FileSystemPath) => {\n  if (fullPath.length < prefix.length) return false;\n  for (let i = 0; i < prefix.length; ++i) {\n    if (fullPath[i] === prefix[i]) continue;\n    return false;\n  }\n  return true;\n};\n\n/**\n * Parses a string into the file system path it represents\n */\nexport const parsePathString = (pathString: string): FileSystemPath => {\n  pathString = pathString.trim();\n  if (pathString.length === 0) return [];\n  const segments = pathString.split('/');\n  return segments;\n};\n\n/**\n * Convert a FileSystemPath to plain string path.\n */\nexport const getPathString = (path: FileSystemPath): string => {\n  return path.join('/');\n};\n\n/**\n * Return the parent path of the specified path.\n */\nexport const getParentPath = (path: FileSystemPath): FileSystemPath => {\n  return path.slice(0, -1);\n};\n","import { v4 as uuid } from 'uuid';\nimport Tree, { TreeInternalNode, TreeNode, TreePath } from '../utils/tree';\nimport { InvalidArgError } from '../utils/errors';\nimport { getParentPath } from '../utils/path-utils';\n\nexport type FileBlob = {\n  contentToken: string;\n  version: number;\n};\n\nexport type FileName = string;\nexport type FileSystemTree = Tree<FileBlob, FileName>;\nexport type FileSystemNode = TreeNode<FileBlob, FileName>;\nexport type FileSystemInternalNode = TreeInternalNode<FileBlob, FileName>;\nexport type FileSystemPath = TreePath<FileName>;\n\n/**\n * A simple in-memory file system with support CRUD-like\n * operations and copy-move functionality.\n */\nexport default class FileSystem {\n  _fs: FileSystemTree;\n\n  /**\n   * Create a new FileSystem, optionally with the provided\n   * file system tree or tree node.\n   */\n  constructor(fs?: FileSystemTree | FileSystemInternalNode) {\n    if (!fs) this._fs = new Tree();\n    else {\n      if (fs instanceof Tree) this._fs = fs;\n      else this._fs = new Tree(fs);\n    }\n  }\n\n  /**\n   * Immutability helper class: Use this to return a new\n   * FileSystem instance with updated file tree.\n   */\n  private updatedClass = (newFS: FileSystemTree): FileSystem => {\n    if (newFS === this._fs) return this;\n    else return new FileSystem(newFS);\n  };\n\n  /**\n   * Check whether the provided node is a file blob.\n   */\n  static isFile = (node?: FileSystemNode | null): node is FileBlob => {\n    if (!node) return false;\n    return Tree.isLeafNode(node);\n  };\n\n  /**\n   * Check whether the provided node is a directory node.\n   */\n  static isDirectory = (\n    node?: FileSystemNode | null\n  ): node is FileSystemInternalNode => {\n    if (!node) return false;\n    return Tree.isInternalNode(node);\n  };\n\n  /**\n   * Create a new file blob seeded randomly.\n   *\n   * @param token Use this to override the random seed.\n   * USE ONLY FOR TESTING.\n   */\n  static generateFileBlob = (token?: string): FileBlob => ({\n    contentToken: token || uuid(),\n    version: 0,\n  });\n\n  /**\n   * Get the node located at specified path in the file system.\n   */\n  get = (path: FileSystemPath): FileSystemNode | null => {\n    if (path.length === 0) return this._fs._tree;\n    return this._fs.get(path);\n  };\n\n  /**\n   * Checks if a path lies inside, at the boundary or entirely\n   * outside the file system tree. Returns a number, representing:\n   *\n   * - 0: Path corresponds to root of filesystem\n   * - 1: Path leads to an internal node\n   * - 2: Path leads to a leaf of filesystem\n   * - 3: Path does not exist, parent is directory\n   * - 4: Path does not exist, parent is leaf\n   * - 5: Neither path nor its parent exists\n   */\n  getPathDepth = (path: FileSystemPath): number => {\n    if (path.length === 0) return 0;\n    // Check parent node\n    const parent = this.get(getParentPath(path));\n    if (!parent) return 5;\n    if (FileSystem.isFile(parent)) return 4;\n    // Parent is directory: check child node\n    const node = parent.get(path[path.length - 1]);\n    if (!node) return 3;\n    if (FileSystem.isFile(node)) return 2;\n    return 1;\n  };\n\n  /**\n   * Create a new file or empty directory at the specified path.\n   *\n   * Throws if path terminates prematurely or already exists.\n   */\n  create = (path: FileSystemPath, type: 'file' | 'directory'): FileSystem => {\n    if (this.get(path)) throw new InvalidArgError('Already exists');\n    const item = type === 'file' ? FileSystem.generateFileBlob() : undefined;\n    const newFS = this._fs.insert(path, item);\n    return this.updatedClass(newFS);\n  };\n\n  /**\n   * Delete node located at specified path in file system.\n   *\n   * Throws if path does not exist.\n   */\n  delete = (path: FileSystemPath): FileSystem => {\n    const item = this.get(path);\n    if (!item) throw new InvalidArgError();\n    const newFS = this._fs.remove(path);\n    return this.updatedClass(newFS);\n  };\n\n  /**\n   * Check if item at specified path exists. If `type` is provided,\n   * also checks if the item matches provided type.\n   */\n  has = (path: FileSystemPath, type?: 'file' | 'directory'): boolean => {\n    const item = this.get(path);\n    if (!item) return false;\n    if (!type) return true;\n    if (type === 'file' && FileSystem.isFile(item)) return true;\n    if (type === 'directory' && FileSystem.isDirectory(item)) return true;\n    return false;\n  };\n\n  /**\n   * Bump the version of file located at specified path by 1.\n   *\n   * Throws if path does not lead to file.\n   */\n  bumpFileVersion = (path: FileSystemPath): FileSystem => {\n    if (path.length === 0) throw new InvalidArgError();\n    const file = this.get(path);\n    if (!FileSystem.isFile(file)) throw new InvalidArgError();\n    const newFile = { ...file, version: file.version + 1 };\n    const newFS = this._fs.update(path, newFile);\n    return this.updatedClass(newFS);\n  };\n\n  /**\n   * Move a node from one location in file system to another.\n   * Use with care: overwrites anything located at the destination path.\n   *\n   * Removes the node at source path by default. Pass `preserveSrc: true` to\n   * *copy* the node to destination instead.\n   */\n  move = (\n    srcPath: FileSystemPath,\n    destPath: FileSystemPath,\n    preserveSrc?: boolean\n  ): FileSystem => {\n    // Validate source path\n    if (srcPath.length === 0) throw new InvalidArgError('Bad source');\n    const item = this.get(srcPath);\n    if (!item) throw new InvalidArgError('Bad source');\n\n    // Validate destination path\n    if (destPath.length === 0) throw new InvalidArgError('Bad destination');\n    const destDirPath = destPath.slice(0, -1);\n    const destDir = this.get(destDirPath);\n    if (!FileSystem.isDirectory(destDir))\n      throw new InvalidArgError('Bad destination');\n\n    // Make a copy of the item and move it\n    // 1. Remove the node already existing at destination\n    const destExists = !!this._fs.get(destPath);\n    const fsWithoutDest = destExists ? this._fs.remove(destPath) : this._fs;\n    // 2. Add the source item to the destination\n    const destItem = FileSystem.isFile(item) ? { ...item } : item;\n    const fsWithDest = fsWithoutDest.insert(destPath, destItem);\n\n    // Remove the source item if required\n    const newFS = preserveSrc ? fsWithDest : fsWithDest.remove(srcPath);\n    return this.updatedClass(newFS);\n  };\n}\n","export const DEFAULT_BRANCH_NAME = 'master';\n","import { Record } from 'immutable';\nimport { DEFAULT_BRANCH_NAME } from '../../constants';\nimport { GitObjectAddress } from '../object-storage/types';\nimport RefStorage, { RefPath } from '../ref-storage';\n\n// Detached head - points to commit object\ninterface DetachedHeadState {\n  isDetached: true;\n  destination: GitObjectAddress;\n}\n\n// Stable head - points to local ref\ninterface StableHeadState {\n  isDetached: false;\n  destination: RefPath;\n}\n\n// State of Git HEAD\nconst CreateGitHead = Record<DetachedHeadState | StableHeadState>({\n  isDetached: false,\n  destination: [DEFAULT_BRANCH_NAME],\n});\nconst defaultGitHead = CreateGitHead();\nexport type GitHeadState = typeof defaultGitHead;\n\n/**\n * Represents Git HEAD. Can be\n * - stable (pointing towards local ref)\n * - detached (pointing directly to commit)\n */\nexport default class GitHead {\n  _head: GitHeadState;\n\n  /**\n   * Create a fresh Git HEAD, optionally with\n   * provided initial HEAD state.\n   */\n  constructor(head?: GitHeadState) {\n    if (head) this._head = head;\n    else this._head = CreateGitHead();\n  }\n\n  /**\n   * Immutability helper method: use this to return GitHead\n   * instance with updated head state.\n   */\n  private updatedClass = (newHead: GitHeadState): GitHead => {\n    if (newHead === this._head) return this;\n    else return new GitHead(newHead);\n  };\n\n  /**\n   * Detach HEAD to the provided commit address.\n   */\n  detachTo(commitAddr: GitObjectAddress): GitHead {\n    const newHead = this._head\n      .set('isDetached', true)\n      .set('destination', commitAddr);\n    return this.updatedClass(newHead);\n  }\n\n  /**\n   * Update HEAD to point to the provided ref.\n   */\n  attachTo(branchPath: RefPath): GitHead {\n    const newHead = this._head\n      .set('isDetached', false)\n      .set('destination', branchPath);\n    return this.updatedClass(newHead);\n  }\n\n  /**\n   * Update HEAD to the provided commit hash or ref.\n   * If commit hash is provided, resultant head is detached.\n   */\n  updateTo(target: GitObjectAddress | RefPath): GitHead {\n    const targetIsRef = Array.isArray(target);\n    const newHead = this._head\n      .set('isDetached', !targetIsRef)\n      .set('destination', target);\n    return this.updatedClass(newHead);\n  }\n\n  /**\n   * Advance the current HEAD or active branch to provided\n   * commit hash. Used for updating head after new commit.\n   *\n   * @todo Move to RefStorage+Head class?\n   */\n  advanceTo(\n    refStorage: RefStorage,\n    commitHash: GitObjectAddress\n  ): { head: GitHead; refStorage: RefStorage } {\n    if (this._head.isDetached) {\n      const newHead = this.detachTo(commitHash);\n      return { refStorage, head: newHead };\n    } else {\n      const branchName = this._head.destination;\n      const newRefStorage = refStorage.update(branchName, commitHash);\n      return { refStorage: newRefStorage, head: this };\n    }\n  }\n\n  /**\n   * Get the hash of the commit pointed to by current HEAD.\n   *\n   * @todo Move to RefStorage+Head class?\n   */\n  getTargetCommit(refStorage: RefStorage): GitObjectAddress {\n    if (this._head.isDetached) return this._head.destination;\n    else return refStorage.readLeaf(this._head.destination);\n  }\n}\n","import { createHash, Hash } from 'crypto';\nimport {\n  GitObject,\n  GitObjectAddress,\n  GitBlob,\n  GitTree,\n  GitCommit,\n} from './types';\n\nconst HASH_METHOD = 'sha1';\n\n/**\n * Computes the SHA-1 hash of a given Git object\n */\nexport const hashObject = (object: GitObject): GitObjectAddress => {\n  if (object.type === 'blob') return hashBlobObject(object);\n  else if (object.type === 'tree') return hashTreeObject(object);\n  else return hashCommitObject(object);\n};\n\n/**\n * Computes the SHA-1 hash of a Git blob object\n */\nexport const hashBlobObject = (blob: GitBlob): GitObjectAddress => {\n  const { contentToken, version } = blob.fileData;\n  const finalToken = contentToken + ' ' + version.toString();\n  return createHash(HASH_METHOD).update(finalToken).digest('hex');\n};\n\n/**\n * Computes the SHA-1 hash of a Git tree object\n */\nexport const hashTreeObject = (tree: GitTree): GitObjectAddress => {\n  return Array.from(tree.items)\n    .reduce<Hash>((currentHash: Hash, [fileName, hashPath]) => {\n      // Serialize item to string and update hash\n      const itemString = fileName + '|' + hashPath;\n      return currentHash.update(itemString);\n    }, createHash(HASH_METHOD))\n    .digest('hex');\n};\n\n/**\n * Computes the SHA-1 hash of a Git commit object\n */\nexport const hashCommitObject = (commit: GitCommit): GitObjectAddress => {\n  const hasher = createHash(HASH_METHOD);\n  hasher.update(commit.message);\n  hasher.update(commit.parent || '');\n  hasher.update(commit.workTree);\n  hasher.update(commit.timestamp.toISOString());\n  return hasher.digest('hex');\n};\n","import { GitBlob, GitTree } from './types';\nimport Tree from '../../utils/tree';\nimport ObjectStorage from './index';\nexport type SerializedGitTree = Tree<GitBlob, string>;\n\n/**\n * Walks through and serializes a Git work tree into\n * a direct tree format. Returns `null` if given hash\n * does not correspond to a tree object.\n *\n * @todo Write tests for this\n */\nexport const serializeGitTree = (\n  tree: GitTree,\n  storage: ObjectStorage\n): SerializedGitTree => {\n  // Iterate through children and add to serialized tree\n  return Array.from(tree.items).reduce((mainNode, child) => {\n    const [childName, hash] = child;\n    const subNode = storage.read(hash);\n    if (!subNode || subNode.type === 'commit')\n      throw new Error('Commit object pointed to by tree object');\n    // Blobs are leaf of serialized tree, so set directly\n    if (subNode.type === 'blob') return mainNode.insert([childName], subNode);\n    // Recursively serialize subtrees, and attach to target tree\n    const serializedSubTree = serializeGitTree(subNode, storage);\n    if (!serializedSubTree) throw new Error(`This shouldn't happen.`);\n    return mainNode.insert([childName], serializedSubTree._tree);\n  }, new Tree() as SerializedGitTree);\n};\n","import { List } from 'immutable';\nimport { Apocalypse, InvalidArgError } from './errors';\n\n/**\n * A single item in the sorted array.\n */\nexport type SortedArrayItem<K, V> = { key: K; value: V };\n\n/**\n * Type for a function that compares two keys and returns:\n * - `positive num`: if first element is larger,\n * - `negative num`: if second element is larger,\n * - `zero`: if the elements are equal.\n */\ntype CompareFunction<K> = (a: K, b: K) => number;\n\n/**\n * A simple implementation of a sorted array data structure, that\n * allows you to store items sortable by key. `K`: item key, `V`: item value\n *\n * Multiple items with identical keys are not allowed.\n *\n * - Get item by key: `O(log n)`\n * - Update item value: `O(log n)`\n * - Insert item: `O(n)`\n * - Delete item: `O(n)`\n * - Find range: `O(l + log n)` (`l`: length of required range)\n */\nexport default class SortedArray<K, V> {\n  _items: List<SortedArrayItem<K, V>>;\n  _compareFn: CompareFunction<K>;\n\n  /**\n   * Create a new SortedArray initialized with the provided\n   * comparator and optionally with the provided data.\n   *\n   * Pass `isSorted: true` if provided data is already sorted.\n   */\n  constructor(\n    compareFn: CompareFunction<K>,\n    items?: SortedArrayItem<K, V>[] | List<SortedArrayItem<K, V>>,\n    isSorted: boolean = false\n  ) {\n    Object.freeze(compareFn); // Just a precaution.\n    this._compareFn = compareFn;\n    if (!items) this._items = List();\n    else {\n      let itemsList = List(items);\n      if (!isSorted)\n        itemsList = itemsList.sort((a, b) => {\n          const result = compareFn(a.key, b.key);\n          if (result === 0) throw new InvalidArgError('Duplicate-key items');\n          return result;\n        });\n      this._items = itemsList;\n    }\n  }\n\n  /**\n   * Immutability helper method: use this to return\n   * SortedArray class with new data.\n   *\n   * Pass `sort: true` if new data needs to be sorted.\n   */\n  private updatedClass = (\n    newItems: List<SortedArrayItem<K, V>>,\n    sort?: boolean\n  ) => {\n    if (newItems === this._items) return this;\n    else return new SortedArray(this._compareFn, newItems, !sort);\n  };\n\n  /**\n   * Get an element value and index by its key or key-finder.\n   * If element does not exist, returns its expected position.\n   *\n   * @param key Can be the key of element to find, or a key-finder function\n   * that acts as comparator for finding element with required key. If key-finder\n   * returns 0 for multiple elements, the first found element is returned.\n   */\n  get = (\n    key: K | ((k: K) => number)\n  ): { item: SortedArrayItem<K, V> | null; index: number } => {\n    let lowIndex = 0;\n    let highIndex = this._items.size - 1;\n\n    // Create a compare function that takes care of both `key` types\n    const compareFn = (argKey: K) => {\n      if (typeof key === 'function') return (key as (k: K) => number)(argKey);\n      else return this._compareFn(argKey, key);\n    };\n\n    // Run binary search on the array\n    while (lowIndex <= highIndex) {\n      const midIndex = Math.floor((lowIndex + highIndex) / 2);\n      const item = this._items.get(midIndex);\n      if (!item) throw new Apocalypse();\n      const compared = compareFn(item.key);\n\n      if (compared === 0) return { item, index: midIndex };\n      else if (compared < 0) lowIndex = midIndex + 1;\n      else if (compared > 0) highIndex = midIndex - 1;\n    }\n\n    // Hasn't returned yet? Item does not exist\n    if (lowIndex - highIndex !== 1) throw new Apocalypse();\n    return { item: null, index: lowIndex };\n  };\n\n  /**\n   * Return item located at given index in the SortedArray\n   * @todo Write tests for this?\n   */\n  itemAt = (index: number) => this._items.get(index, null);\n\n  /**\n   * Return the number of elements in the SortedArray.\n   * @todo Write tests for this?\n   */\n  size = (): number => this._items.size;\n\n  /**\n   * Inserts a new item into the SortedArray.\n   * If `upsert: true` is provided, updates the item if\n   * an item with same key already exists.\n   *\n   * Throws if `upsert: false` and key already exists.\n   */\n  insert = (\n    newItem: SortedArrayItem<K, V>,\n    upsert?: boolean\n  ): SortedArray<K, V> => {\n    const { item, index } = this.get(newItem.key);\n    if (item && !upsert) throw new InvalidArgError('Already exists');\n    else if (item) {\n      // `upsert` provided, so update existing time\n      const newItems = this._items.set(index, newItem);\n      return this.updatedClass(newItems);\n    } else {\n      // Insert new item at index\n      const newItems = this._items.insert(index, newItem);\n      return this.updatedClass(newItems);\n    }\n  };\n\n  /**\n   * Updates the value of an item in the SortedArray.\n   * If `upsert: true` is provided, inserts new item if it does not exist.\n   *\n   * Throws if `upsert` is not provided and item does not exist.\n   */\n  update = (itemKey: K, newValue: V, upsert?: boolean): SortedArray<K, V> => {\n    const { item, index } = this.get(itemKey);\n    if (!item && !upsert) throw new InvalidArgError('Key not found');\n    else if (!item) {\n      // `upsert` provided, insert new item\n      const newItem = { key: itemKey, value: newValue };\n      const newItems = this._items.insert(index, newItem);\n      return this.updatedClass(newItems);\n    } else {\n      // Update existing item\n      const newItems = this._items.update(index, (item) => ({\n        ...item,\n        value: newValue,\n      }));\n      return this.updatedClass(newItems);\n    }\n  };\n\n  /**\n   * Removes an item from the SortedArray. Does nothing\n   * if the item does not exist.\n   */\n  remove = (itemKey: K): SortedArray<K, V> => {\n    const { item, index } = this.get(itemKey);\n    if (!item) throw new InvalidArgError();\n    const newItems = this._items.delete(index);\n    return this.updatedClass(newItems);\n  };\n\n  /**\n   * Returns the start and end index of the subarray, for the\n   * element keys of which `searchFn` returns 0. Note that the end\n   * index returned is one past the actual subarray limits.\n   *\n   * Ensure that `searchFn` is consistent, ie will return 0 only for a\n   * single contiguous subarray of the full array.\n   *\n   * @param searchFn Takes a key and returns 0 if it is part of required subarray,\n   * -1 if it lies before the required subarray, 1 if it lies after.\n   */\n  findRange = (searchFn: (kr: K) => number): { start: number; end: number } => {\n    const { item, index } = this.get(searchFn);\n    if (!item) return { start: index, end: index };\n\n    // We have one position of the required range\n    // Touch around to find the full range required\n    let startIndex = index;\n    while (startIndex > 0) {\n      const item = this._items.get(startIndex - 1);\n      if (!item) throw new Apocalypse();\n      if (searchFn(item.key) === 0) --startIndex;\n      else break;\n    }\n    // Find the subarray end index\n    let endIndex = index;\n    while (endIndex < this._items.size) {\n      const item = this._items.get(endIndex);\n      if (!item) throw new Apocalypse();\n      if (searchFn(item.key) === 0) ++endIndex;\n      else break;\n    }\n\n    return { start: startIndex, end: endIndex };\n  };\n}\n","import { FileSystemPath } from '../../file-system';\nimport { Apocalypse } from '../../utils/errors';\nimport Tree from '../../utils/tree';\nimport IndexFile, { IndexFileItem } from './index';\n\nexport type IndexTree = Tree<IndexFileItem, string>;\n\n/**\n * From a sorted-array format index file, creates an index tree\n * with leaves representing each index entry.\n *\n * Throws if the index file does not represent a valid tree, ie\n * there are index entries both for a path and its subpath.\n *\n * Algorithm:\n * 1. Split index file into chunks representing each file/directory under root.\n * 2. For each chunk:\n *     1. If chunk represents direct file entry, add leaf to index tree.\n *     2. Else, recursively create index tree for chunk and attach to root tree.\n */\nexport const createIndexTree = (index: IndexFile): IndexTree => {\n  const filePaths = index.entries().map((a) => a.path);\n  const chunks = getRootNameChunks(filePaths);\n\n  return chunks.reduce((rootNode, chunk) => {\n    // Check if chunk corresponds to file entry\n    if (chunk.end - chunk.start === 1) {\n      // Chunk may correspond to file entry...\n      const indexEntry = index._index.itemAt(chunk.start);\n      if (!indexEntry) throw new Apocalypse();\n      if (indexEntry.key.length === 1) {\n        // Chunk corresponds to file entry: add leaf to index tree\n        return rootNode.insert([chunk.name], indexEntry.value);\n      }\n    }\n\n    // Create sub-index corresponding to chunk\n    const subIndexItems = index._index._items\n      .slice(chunk.start, chunk.end)\n      .map((item) => ({ ...item, key: item.key.slice(1) }));\n    const subIndex = new IndexFile(subIndexItems);\n    // Recursively create index tree for sub-index\n    const subIndexTree = createIndexTree(subIndex);\n    // Attach sub-index tree to root node\n    return rootNode.insert([chunk.name], subIndexTree._tree);\n  }, new Tree() as Tree<IndexFileItem, string>);\n};\n\n/**\n * Given a **sorted** list of file paths, returns a list of \"name chunks\".\n * Each name chunk corresponds to a subarray of the file path list, with\n * - name: the common first path segment of the paths in subarray\n * - start: start position of subarray in original array\n * - end: one index after the end position of subarray\n *\n * Throws, if a given path is empty.\n */\nconst getRootNameChunks = (fullPaths: FileSystemPath[]): NameChunk[] => {\n  if (fullPaths.length === 0) return [];\n\n  // Each chunk stores item name and indices where its segment starts\n  // and ends in the provided list of paths\n  const chunks: NameChunk[] = [];\n  let index: number = -1; // Index of file path being considered\n  let currentStart: number = -1; // Start index of current chunk\n  let currentName: string = ''; // Item name in current chunk\n\n  // Loop through paths and push to chunks\n  while (index < fullPaths.length - 1) {\n    // Empty paths are not allowed\n    const path = fullPaths[++index];\n    if (path.length === 0) throw new Error('Empty path found');\n    const itemName = path[0];\n    if (itemName === currentName) continue;\n\n    // If chunk has changed...\n    if (index !== 0) {\n      // Push previous chunk to list. There's no previous chunk for index = 0.\n      chunks.push({ name: currentName, start: currentStart, end: index });\n    }\n    // Prepare for next chunk\n    currentStart = index;\n    currentName = itemName;\n  }\n\n  // Push the last chunk\n  chunks.push({ name: currentName, start: currentStart, end: index + 1 });\n  return chunks;\n};\n\ntype NameChunk = {\n  name: string;\n  start: number;\n  end: number;\n};\n","import FileSystem, { FileSystemNode, FileSystemPath } from '../../file-system';\nimport Tree from '../../utils/tree';\nimport ObjectStorage from '../object-storage';\nimport { hashBlobObject } from '../object-storage/hash-object';\nimport { GitBlob, GitObjectAddress, GitTree } from '../object-storage/types';\nimport { serializeGitTree } from '../object-storage/utils';\nimport SortedArray, { SortedArrayItem } from '../../utils/sorted-array';\nimport { isPrefix } from '../../utils/path-utils';\nimport { Apocalypse, InvalidArgError } from '../../utils/errors';\nimport { List } from 'immutable';\nimport { createIndexTree, IndexTree } from './create-index-tree';\n\nexport interface IndexFileItem {\n  objectHash: GitObjectAddress;\n}\n\nexport type IndexArray = SortedArray<FileSystemPath, IndexFileItem>;\nexport type IndexArrayItem = SortedArrayItem<FileSystemPath, IndexFileItem>;\n\n/**\n * Compare two strings lexicographically.\n * Return -1, 0 or 1 accordingly.\n */\nconst compareNames = (a: string, b: string): number => a.localeCompare(b);\n\n/**\n * Compare two filepaths segment-wise lexicographically.\n * Returns -1, 0, 1 accordingly.\n */\nexport const comparePaths = (a: FileSystemPath, b: FileSystemPath): number => {\n  if (a.length === 0 && b.length === 0) return 0;\n  else if (a.length === 0) return -1;\n  else if (b.length === 0) return 1;\n  else {\n    const nameCmp = compareNames(a[0], b[0]);\n    if (nameCmp !== 0) return nameCmp;\n    return comparePaths(a.slice(1), b.slice(1));\n  }\n};\n\n/**\n * The index file acts as a cache between the file system tree and\n * the Git working tree. The structure is identical to a tree, with\n * leaves representing the files in the index.\n *\n * The index file plays the following roles:\n * - Compare index with FS or working tree to get unstaged/staged changes\n * - Working tree in index file is used as work tree for next commit\n */\nexport default class IndexFile {\n  _index: IndexArray;\n\n  /**\n   * Create a new IndexFile, optionally initialized with provided entries.\n   * If `index` is provided as `List<IndexArrayItem>`, ensure that the list is pre-sorted.\n   */\n  constructor(index?: IndexArray | List<IndexArrayItem>) {\n    if (!index) this._index = new SortedArray(comparePaths);\n    else if (index instanceof SortedArray) this._index = index;\n    else this._index = new SortedArray(comparePaths, index, true);\n  }\n\n  /**\n   * Immutability helper method: use this to return IndexFile\n   * instance with updated index entries.\n   */\n  private updatedClass = (newIndex: IndexArray) => {\n    if (this._index === newIndex) return this;\n    else return new IndexFile(newIndex);\n  };\n\n  /**\n   * Returns the number of entries in index.\n   */\n  size = (): number => {\n    return this._index.size();\n  };\n\n  /**\n   * Returns the index entries, sorted by path.\n   */\n  entries = (): { path: FileSystemPath; entry: IndexFileItem }[] => {\n    const rawEntries = [...this._index._items.entries()];\n    return rawEntries.map((a) => ({ path: a[1].key, entry: a[1].value }));\n  };\n\n  /**\n   * Create an index tree from given file system tree.\n   * May add objects to object storage for creating index entries.\n   */\n  static fromFileTree = (\n    fileTree: FileSystemNode,\n    objectStorage: ObjectStorage,\n    basePath: FileSystemPath = []\n  ): { storage: ObjectStorage; indexFile: IndexFile } => {\n    // Serialize file tree into its leaves\n    const fileTreeLeaves = FileSystem.isFile(fileTree)\n      ? [{ path: basePath, value: fileTree }]\n      : new Tree(fileTree).toLeafArray(compareNames, basePath);\n\n    // Convert file tree leaves to index file entries\n    let newStorage = objectStorage;\n    const indexEntries = fileTreeLeaves.map((leaf) => {\n      const gitBlob: GitBlob = { type: 'blob', fileData: leaf.value };\n      const { storage: objS, hash } = newStorage.write(gitBlob);\n      newStorage = objS;\n      return { key: leaf.path, value: { objectHash: hash } };\n    });\n\n    // Pack the entries into a SortedArray\n    const index = new SortedArray(comparePaths, indexEntries);\n    return { storage: newStorage, indexFile: new IndexFile(index) };\n  };\n\n  /**\n   * Creates an index tree from a Git tree.\n   * Returns `null` if given hash does not point to a tree.\n   *\n   * @todo Write tests for this\n   */\n  static fromGitTree = (\n    objectStorage: ObjectStorage,\n    tree: GitTree\n  ): IndexFile => {\n    // Serialize Git tree into an array of Git blobs\n    const serializedTree = serializeGitTree(tree, objectStorage);\n    const gitBlobLeaves = serializedTree.toLeafArray(compareNames);\n\n    // Convert Git blob leaves to index file entries\n    const indexEntries = gitBlobLeaves.map((leaf) => {\n      const gitBlob = leaf.value;\n      const objectHash = hashBlobObject(gitBlob);\n      return { key: leaf.path, value: { objectHash } };\n    });\n\n    // Pack the entries into a SortedArray\n    const newIndex = new SortedArray(comparePaths, indexEntries);\n    return new IndexFile(newIndex);\n  };\n\n  /**\n   * Get index entry at specified path.\n   * Returns `null` if no entry exists at path.\n   */\n  get = (path: FileSystemPath): IndexFileItem | null => {\n    if (path.length === 0) throw new InvalidArgError();\n    const item = this._index.get(path).item;\n    return item && item.value;\n  };\n\n  /**\n   * Updates the index entry at provided path.\n   * Insert entry if it does not exist.\n   *\n   * Always succeeds, unless empty path is provided.\n   */\n  upsert = (path: FileSystemPath, value: IndexFileItem): IndexFile => {\n    if (path.length === 0) throw new InvalidArgError();\n    const newIndex = this._index.update(path, value, true);\n    return this.updatedClass(newIndex);\n  };\n\n  /**\n   * Removes index entry at provided path.\n   *\n   * Throws if no entry exists at path.\n   */\n  remove = (path: FileSystemPath): IndexFile => {\n    if (path.length === 0) throw new InvalidArgError();\n    if (!this._index.get(path).item) throw new InvalidArgError();\n    const newIndex = this._index.remove(path);\n    return this.updatedClass(newIndex);\n  };\n\n  /**\n   * Alias for `createIndexTree`. Converts the index file\n   * to a tree format.\n   */\n  toTree = (): IndexTree => {\n    return createIndexTree(this);\n  };\n\n  /**\n   * Gets the start and end index of the section of index file\n   * that contains entries at or under the specified path.\n   */\n  getPathSection = (path: FileSystemPath): { start: number; end: number } => {\n    return this._index.findRange((entryPath) => {\n      const isSubpath = isPrefix(entryPath, path);\n      if (isSubpath) return 0;\n      return comparePaths(entryPath, path);\n    });\n  };\n\n  /**\n   * Overwrites a part of the index file with the sub-index file provided.\n   * The part overwritten is that which represents the index for given path.\n   *\n   * Fails if sub-index does not \"fit\" into the main index, ie a blind overwrite\n   * would lead to an invalid index file.\n   *\n   * Ensure that the provided sub-index is self-consistent. If not,\n   * the full index file will also become inconsistent.\n   *\n   * @param indexFile The index file, a part of which is to be overwritten.\n   * @param path Determines the section of index file to be overwritten.\n   * @param subIndex The replacement for overwritten section.\n   *\n   * @todo Write tests for this!\n   */\n  overwriteSection = (\n    path: FileSystemPath,\n    subIndex: IndexFile | IndexArray\n  ): IndexFile => {\n    // Get the underlying array of sub-index provided\n    if (subIndex instanceof IndexFile) subIndex = subIndex._index;\n\n    // Find the section of index file to be overwritten\n    const sectionLimits = this.getPathSection(path);\n\n    // Validate that provided sub-index file fits in\n    if (subIndex.size() !== 0) {\n      if (sectionLimits.start > 0) {\n        // Check the starting boundary\n        const itemBeforeSplit = this._index.itemAt(sectionLimits.start - 1);\n        const firstSubItem = subIndex.itemAt(0);\n        if (!itemBeforeSplit || !firstSubItem) throw new Apocalypse();\n        if (comparePaths(itemBeforeSplit.key, firstSubItem.key) !== -1)\n          throw new InvalidArgError();\n      }\n      if (sectionLimits.end < this._index.size()) {\n        // Check the ending boundary\n        const itemAfterSplit = this._index.itemAt(sectionLimits.end);\n        const lastSubItem = subIndex.itemAt(subIndex.size() - 1);\n        if (!itemAfterSplit || !lastSubItem) throw new Apocalypse();\n        if (comparePaths(itemAfterSplit.key, lastSubItem.key) !== 1)\n          throw new InvalidArgError();\n      }\n    }\n\n    // Insert the provided sub-index array\n    const preSection = this._index._items.slice(0, sectionLimits.start);\n    const postSection = this._index._items.slice(sectionLimits.end);\n    const newIndexRawItems = [\n      ...preSection,\n      ...subIndex._items,\n      ...postSection,\n    ];\n    const newIndex = new SortedArray(comparePaths, newIndexRawItems, true);\n    return this.updatedClass(newIndex);\n  };\n}\n","import { Map } from 'immutable';\nimport { hashObject } from './hash-object';\nimport { GitObjectStorage, GitObject, GitObjectAddress } from './types';\n\n/**\n * The object storage is a database where Git objects are\n * stored against their SHA-1 hash. These objects include:\n * - blobs: represent the contents and metadata of a single file\n * - trees: represent a directory of blobs and further trees\n * - commits: represent a single commit, consisting\n *   - commit message\n *   - time of committing\n *   - SHA-1 of the parent commit\n *   - SHA-1 of the corresponding work tree\n *\n * The object storage is:\n * - content-addressable: if you have the object, you can find its key using SHA-1\n * - key-value: Objects are stored against their keys, which are SHA-1 hashes\n * - a graph:\n *   - commits point to trees and parent commits\n *   - trees point to blobs and subtrees\n *   - blobs are leafs of the graph\n */\nexport default class ObjectStorage {\n  _db: GitObjectStorage;\n\n  constructor(db?: GitObjectStorage) {\n    if (db) this._db = db;\n    else this._db = Map();\n  }\n\n  /**\n   * Immutability helper method: use this to return ObjectStorage\n   * instance with updated object database.\n   */\n  private updatedClass = (db: GitObjectStorage): ObjectStorage => {\n    if (this._db === db) return this;\n    else return new ObjectStorage(db);\n  };\n\n  /**\n   * Read an object located in object storage.\n   */\n  read = (hash: GitObjectAddress): GitObject | null => {\n    return this._db.get(hash, null);\n  };\n\n  /**\n   * Write a new object to the object storage.\n   * Does nothing if object already exists.\n   */\n  write = (\n    object: GitObject\n  ): { storage: ObjectStorage; hash: GitObjectAddress } => {\n    const hash = hashObject(object);\n    const newDB = this._db.set(hash, object);\n    return { storage: this.updatedClass(newDB), hash };\n  };\n\n  /**\n   * Delete an object from object storage.\n   * Does nothing if object does not exist.\n   */\n  delete = (hash: GitObjectAddress): ObjectStorage => {\n    if (!this._db.has(hash)) return this;\n    const newDB = this._db.delete(hash);\n    return this.updatedClass(newDB);\n  };\n\n  /**\n   * Get entries of the object storage\n   */\n  entries = (): { hash: GitObjectAddress; object: GitObject }[] => {\n    const dbEntries = [...this._db.entries()];\n    return dbEntries.map((a) => ({ hash: a[0], object: a[1] }));\n  };\n}\n","import { GitObjectAddress } from '../object-storage/types';\nimport Tree, { TreeInternalNode, TreeNode, TreePath } from '../../utils/tree';\nimport { InvalidArgError } from '../../utils/errors';\nimport { DEFAULT_BRANCH_NAME } from '../../constants';\n\nexport type RefName = string;\nexport type RefPath = TreePath<RefName>;\nexport type RefTreeLeaf = GitObjectAddress;\nexport type RefTree = Tree<RefTreeLeaf, RefName>;\nexport type RefTreeNode = TreeNode<RefTreeLeaf, RefName>;\nexport type RefTreeInternalNode = TreeInternalNode<RefTreeLeaf, RefName>;\n\nconst defaultBranchHeads: RefTree = new Tree<RefTreeLeaf, RefName>().insert(\n  [DEFAULT_BRANCH_NAME],\n  ''\n);\n\n/**\n * Represents the ref storage of a Git repository.\n * Maintains local refs (branches) and remote refs in tree format.\n */\nexport interface GitRefStorage {\n  branchHeads: RefTree;\n}\n\n/**\n * The ref storage is a tree structure for storing\n * Git refs - both local and remote, in separate namespaces.\n * This storage corresponds to the directory `.git/refs`.\n *\n * The actual refs, i.e leaf nodes of the tree, contain the SHA-1\n * hash address to corresponding commit objects in the object storage.\n */\nexport default class RefStorage {\n  _branchHeads: RefTree;\n\n  /**\n   * Create a new instance of RefStorage, optionally\n   * initialized with provided ref tree.\n   */\n  constructor(branchHeads?: RefTree | RefTreeInternalNode) {\n    if (!branchHeads) this._branchHeads = defaultBranchHeads;\n    else {\n      if (branchHeads instanceof Tree) this._branchHeads = branchHeads;\n      else this._branchHeads = new Tree(branchHeads);\n    }\n  }\n\n  /**\n   * Immutability helper method: use this to return RefStorage\n   * instance with updated ref tree.\n   */\n  private updatedClass = (newBranchHeads: RefTree): RefStorage => {\n    if (newBranchHeads === this._branchHeads) return this;\n    else return new RefStorage(newBranchHeads);\n  };\n\n  /**\n   * Checks if the provided node is a leaf ref.\n   */\n  static isLeaf = (node: RefTreeNode | null): node is RefTreeLeaf => {\n    if (node === null) return false;\n    else return typeof node === 'string';\n  };\n\n  /**\n   * Return the node located at given path in ref tree.\n   */\n  get = (path: RefPath): RefTreeNode | null => {\n    if (path.length === 0) return this._branchHeads._tree;\n    else return this._branchHeads.get(path);\n  };\n\n  /**\n   * Read the commit hash that a leaf ref points to.\n   */\n  readLeaf = (path: RefPath): GitObjectAddress => {\n    if (path.length === 0) throw new InvalidArgError();\n    const refNode = this._branchHeads.get(path);\n    if (!RefStorage.isLeaf(refNode)) throw new InvalidArgError();\n    return refNode;\n  };\n\n  /**\n   * Create a new leaf ref at the specified path.\n   *\n   * Throws if ref already exists at path or path terminates prematurely.\n   */\n  create = (path: RefPath, commitHash: GitObjectAddress): RefStorage => {\n    // Check if path is valid\n    if (path.length === 0) throw new InvalidArgError();\n    const existingRef = this._branchHeads.get(path);\n    if (existingRef) throw new InvalidArgError();\n    // Insert leaf ref\n    const newRefTree = this._branchHeads.insert(path, commitHash);\n    return this.updatedClass(newRefTree);\n  };\n\n  /**\n   * Deletes leaf ref located at the specified path.\n   *\n   * Throws if no ref is located at the specified path.\n   */\n  delete = (path: RefPath): RefStorage => {\n    const refNode = this._branchHeads.get(path);\n    if (!RefStorage.isLeaf(refNode)) throw new InvalidArgError();\n    const newRefTree = this._branchHeads.remove(path);\n    return this.updatedClass(newRefTree);\n  };\n\n  /**\n   * Returns list of the direct children of internal ref\n   * located at the specified path.\n   *\n   * Throws if path is invalid or leads to leaf ref.\n   */\n  getChildren = (path: RefPath): [string, RefTreeNode][] => {\n    const node = this._branchHeads.get(path);\n    if (!node || RefStorage.isLeaf(node)) throw new InvalidArgError();\n    return [...node.entries()];\n  };\n\n  /**\n   * Updates the leaf ref located at the specified path to\n   * the new commit address provided.\n   */\n  update = (path: RefPath, commitHash: GitObjectAddress): RefStorage => {\n    if (path.length === 0) throw new InvalidArgError();\n    const refNode = this._branchHeads.get(path);\n    if (!RefStorage.isLeaf(refNode)) throw new InvalidArgError();\n    const newRefTree = this._branchHeads.update(path, commitHash);\n    return this.updatedClass(newRefTree);\n  };\n}\n","import GitHead from './head';\nimport IndexFile from './index-file';\nimport ObjectStorage from './object-storage';\nimport RefStorage from './ref-storage';\nimport { GitRepository } from './types';\n\nexport const createNewRepository = (): GitRepository => {\n  return {\n    indexFile: new IndexFile(),\n    objectStorage: new ObjectStorage(),\n    refStorage: new RefStorage(),\n    head: new GitHead(),\n  };\n};\n","import FileSystem from './file-system';\nimport { createNewRepository } from './git-repository';\nimport { SandboxState } from './types';\n\nexport const createNewSandbox = (): SandboxState => {\n  return {\n    fileSystem: new FileSystem(),\n    repository: createNewRepository(),\n  };\n};\n","import * as React from 'react';\nimport { createNewSandbox } from '../../../simulator';\nimport { SandboxState } from '../../../simulator/types';\n\nconst sampleSandbox = createNewSandbox();\nexport const SandboxContext = React.createContext<SandboxManager>({\n  value: sampleSandbox,\n  setSandbox: () => {},\n});\n\ntype SandboxManager = {\n  value: SandboxState | null;\n  setSandbox: (newSandbox: SandboxState) => void;\n};\n\ntype Props = {\n  children: JSX.Element;\n};\n\n/**\n * Stores and maintains the currently open sandbox.\n */\nexport const SandboxProvider = (props: Props) => {\n  const [sandbox, setSandbox] = React.useState<SandboxState | null>(null);\n\n  // Initialize sandbox\n  React.useEffect(() => {\n    setSandbox(createNewSandbox());\n  }, []);\n\n  const sandboxManager = React.useMemo(\n    () => ({\n      value: sandbox,\n      setSandbox,\n    }),\n    [sandbox]\n  );\n\n  return (\n    <SandboxContext.Provider value={sandboxManager}>\n      {props.children}\n    </SandboxContext.Provider>\n  );\n};\n\n/**\n * Returns the file system of current sandbox.\n * Avoid using where sandbox may not be set.\n */\nexport const useFileSystem = () => {\n  const { value } = React.useContext(SandboxContext);\n  return (value as SandboxState).fileSystem;\n};\n\n/**\n * Returns the repository of current sandbox.\n * Avoid using where sandbox may not be set.\n */\nexport const useRepository = () => {\n  const { value } = React.useContext(SandboxContext);\n  return (value as SandboxState).repository;\n};\n","import clsx from 'classnames';\n\ntype Props = {\n  children: React.ReactNode;\n  accentColor?: string;\n  title?: string;\n  className?: string;\n};\n\nconst Pane = (props: Props) => {\n  const paneClass = clsx('pane', props.className);\n\n  return (\n    <div className='pane-wrapper'>\n      <div className={paneClass} style={{ borderColor: props.accentColor }}>\n        {props.title && (\n          <div\n            className='pane-header'\n            style={{ backgroundColor: props.accentColor }}\n          >\n            {props.title}\n          </div>\n        )}\n        <div className='pane-body'>{props.children}</div>\n      </div>\n    </div>\n  );\n};\n\nexport default Pane;\n","type Props = {\n  message: string;\n  color: string;\n};\n\nexport const EmptyPrompt = (props: Props) => {\n  return (\n    <div className='empty-prompt' style={{ color: props.color }}>\n      <p>{props.message}</p>\n    </div>\n  );\n};\n","import * as React from 'react';\nimport { FileSystemInternalNode } from '../../../simulator/file-system';\nimport { IoChevronForward, IoChevronDown } from 'react-icons/io5';\nimport { DirectoryChildren } from './directory-children';\n\ntype SingleDirectoryItemProps = {\n  name: string;\n  expanded: boolean;\n  onToggleExpand: () => void;\n};\n\nconst SingleDirectoryItem = (props: SingleDirectoryItemProps) => {\n  return (\n    <div className='directory-item-row' onClick={props.onToggleExpand}>\n      <div className='icon'>\n        {props.expanded ? <IoChevronDown /> : <IoChevronForward />}\n      </div>\n      <div className='name'>{props.name}</div>\n    </div>\n  );\n};\n\ntype Props = {\n  name: string;\n  directory: FileSystemInternalNode;\n};\n\nexport const DirectoryItem = (props: Props) => {\n  const [expanded, setExpanded] = React.useState(true);\n  return (\n    <div className='directory-item'>\n      <SingleDirectoryItem\n        name={props.name}\n        expanded={expanded}\n        onToggleExpand={() => setExpanded((e) => !e)}\n      />\n      <DirectoryChildren collapsed={!expanded} directory={props.directory} />\n    </div>\n  );\n};\n","import { FileBlob } from '../../../simulator/file-system';\nimport { IoDocumentOutline } from 'react-icons/io5';\n\ntype Props = {\n  name: string;\n  file: FileBlob;\n};\n\nexport const FileItem = (props: Props) => {\n  const { contentToken, version } = props.file;\n  const fileInfo = `${contentToken.slice(-12)} v${version}`;\n\n  return (\n    <div className='file-item'>\n      <div className='icon'>\n        <IoDocumentOutline />\n      </div>\n      <div className='name' title={fileInfo}>\n        {props.name}\n      </div>\n    </div>\n  );\n};\n","import clsx from 'classnames';\nimport { FileSystemInternalNode } from '../../../simulator/file-system';\nimport Tree from '../../../simulator/utils/tree';\nimport { DirectoryItem } from './directory-item';\nimport { FileItem } from './file-item';\n\ntype DirectoryChildrenProps = {\n  directory: FileSystemInternalNode;\n  collapsed?: boolean;\n};\n\nexport const DirectoryChildren = (props: DirectoryChildrenProps) => {\n  const children = [...props.directory.entries()];\n  const classes = clsx('directory-children', { collapse: props.collapsed });\n\n  return (\n    <div className={classes}>\n      {children.map((child) => {\n        const [childName, childNode] = child;\n        if (Tree.isLeafNode(childNode))\n          return <FileItem key={childName} name={childName} file={childNode} />;\n        return (\n          <DirectoryItem\n            key={childName}\n            name={childName}\n            directory={childNode}\n          />\n        );\n      })}\n    </div>\n  );\n};\n","import FileSystem from '../../../simulator/file-system';\nimport { EmptyPrompt } from '../../ui/empty-prompt';\nimport { DirectoryChildren } from './directory-children';\n\ntype Props = {\n  fileSystem: FileSystem;\n};\n\nexport const FileSystemView = (props: Props) => {\n  const isEmptyFS = props.fileSystem._fs._tree.size === 0;\n\n  return (\n    <div className='file-system-root'>\n      {!isEmptyFS ? (\n        <DirectoryChildren directory={props.fileSystem._fs._tree} />\n      ) : (\n        <EmptyPrompt\n          message='Create a file or directory from the terminal!'\n          color='green'\n        />\n      )}\n    </div>\n  );\n};\n","import { useFileSystem } from '../../mainframe/providers/sandbox-provider';\nimport Pane from '../pane';\nimport { FileSystemView } from './file-system-view';\n\ntype Props = {};\n\nconst FileSystemPane = (props: Props) => {\n  const fileSystem = useFileSystem();\n\n  return (\n    <Pane title='File System' accentColor='green'>\n      <FileSystemView fileSystem={fileSystem} />\n    </Pane>\n  );\n};\n\nexport default FileSystemPane;\n","import clsx from 'classnames';\n\ntype Props = {\n  color: string;\n  text: string;\n  hint?: string;\n  onClick?: () => void;\n  className?: string;\n};\n\nexport const MonospaceChip = (props: Props) => {\n  const classes = clsx('chip', props.className, props.onClick && 'button');\n  return (\n    <div\n      className={classes}\n      style={{ backgroundColor: props.color }}\n      onClick={props.onClick}\n      title={props.hint}\n    >\n      {props.text}\n    </div>\n  );\n};\n","import { FileSystemPath } from '../../../simulator/file-system';\nimport { IndexFileItem } from '../../../simulator/git-repository/index-file';\nimport { getPathString } from '../../../simulator/utils/path-utils';\nimport { MonospaceChip } from '../../ui/monospace-chip';\n\ntype Props = {\n  path: FileSystemPath;\n  indexItem: IndexFileItem;\n};\n\nexport const IndexItemRow = (props: Props) => {\n  const shortHash = props.indexItem.objectHash.slice(-7);\n\n  return (\n    <div className='index-item-row'>\n      <div className='hash'>\n        <MonospaceChip\n          color='darkblue'\n          text={shortHash}\n          hint={props.indexItem.objectHash}\n          onClick={() =>\n            navigator.clipboard.writeText(props.indexItem.objectHash)\n          }\n        />\n      </div>\n      <div className='path'>{getPathString(props.path)}</div>\n    </div>\n  );\n};\n","import { getPathString } from '../../../simulator/utils/path-utils';\nimport { useRepository } from '../../mainframe/providers/sandbox-provider';\nimport { EmptyPrompt } from '../../ui/empty-prompt';\nimport Pane from '../pane';\nimport { IndexItemRow } from './index-item-row';\n\ntype Props = {};\n\nexport const IndexFileView = (props: Props) => {\n  const repository = useRepository();\n  const indexFile = repository.indexFile;\n  const indexItems = indexFile.entries();\n  const isEmptyIndex = indexItems.length === 0;\n\n  return (\n    <Pane title='Index File' accentColor='DarkBlue'>\n      <div className='index-file-root'>\n        {isEmptyIndex ? (\n          <EmptyPrompt message='The index file is empty!' color='DarkBlue' />\n        ) : (\n          indexItems.map((item) => (\n            <IndexItemRow\n              key={getPathString(item.path)}\n              path={item.path}\n              indexItem={item.entry}\n            />\n          ))\n        )}\n      </div>\n    </Pane>\n  );\n};\n","import { GitObject } from '../../../simulator/git-repository/object-storage/types';\nimport { MonospaceChip } from '../../ui/monospace-chip';\n\nconst getDisplayString = (object: GitObject) => {\n  if (object.type === 'blob') {\n    const shortContentToken = object.fileData.contentToken.slice(-12);\n    const fileVersion = object.fileData.version;\n    return `blob: ${shortContentToken}, v${fileVersion}`;\n  } else if (object.type === 'tree') {\n    const numChildren = object.items.size;\n    return `tree: ${numChildren} children`;\n  } else {\n    const commitMessage = object.message;\n    return `commit: ${commitMessage}`;\n  }\n};\n\ntype Props = {\n  hash: string;\n  object: GitObject;\n};\n\nexport const ObjectRow = (props: Props) => {\n  return (\n    <div className='object-row'>\n      <div className='hash' title={props.hash}>\n        <MonospaceChip\n          text={props.hash.slice(-7)}\n          color='purple'\n          hint={props.hash}\n          onClick={() => navigator.clipboard.writeText(props.hash)}\n        />\n      </div>\n      <div className='object'>{getDisplayString(props.object)}</div>\n    </div>\n  );\n};\n","import { useRepository } from '../../mainframe/providers/sandbox-provider';\nimport { EmptyPrompt } from '../../ui/empty-prompt';\nimport Pane from '../pane';\nimport { ObjectRow } from './object-row';\n\ntype Props = {};\n\nconst ObjectStorageView = (props: Props) => {\n  const repository = useRepository();\n  const objectStorage = repository.objectStorage;\n  const objects = [...objectStorage._db.entries()];\n  const isEmpty = objects.length === 0;\n\n  return (\n    <Pane title='Object Storage' accentColor='purple'>\n      <div className='object-storage-root'>\n        {isEmpty ? (\n          <EmptyPrompt message='No objects yet.' color='purple' />\n        ) : (\n          objects.map(([hash, object]) => (\n            <ObjectRow key={hash} hash={hash} object={object} />\n          ))\n        )}\n      </div>\n    </Pane>\n  );\n};\n\nexport default ObjectStorageView;\n","import { useRepository } from '../../mainframe/providers/sandbox-provider';\nimport Pane from '../pane';\n\nconst RepositoryViewerPane = () => {\n  const repository = useRepository();\n\n  return (\n    <Pane title='Repository View' accentColor='red'>\n      <pre>{JSON.stringify(repository, undefined, 2)}</pre>\n    </Pane>\n  );\n};\n\nexport default RepositoryViewerPane;\n","import { useRepository } from '../../mainframe/providers/sandbox-provider';\nimport Pane from '../pane';\n\nconst StagingAreaPane = () => {\n  const repository = useRepository();\n\n  return (\n    <Pane title='Staging Area' accentColor='blue'>\n      <pre>{JSON.stringify(repository, undefined, 2)}</pre>\n    </Pane>\n  );\n};\n\nexport default StagingAreaPane;\n","import FileSystem from '../file-system';\nimport IndexFile from '../git-repository/index-file';\nimport ObjectStorage from '../git-repository/object-storage';\nimport RefStorage from '../git-repository/ref-storage';\nimport GitHead from '../git-repository/head';\nimport { SandboxState } from '../types';\n\n/**\n * Utility function to return system with components\n * overridden with provided arguments. Use for aborting\n * commands when returning error.\n */\nexport const errorState = (\n  system: SandboxState,\n  fileSystem?: FileSystem | null,\n  objectStorage?: ObjectStorage | null,\n  indexFile?: IndexFile | null,\n  head?: GitHead | null,\n  refStorage?: RefStorage | null\n): { system: SandboxState; success: boolean } => {\n  return {\n    success: false,\n    system: {\n      fileSystem: fileSystem || system.fileSystem,\n      repository: {\n        head: head || system.repository.head,\n        objectStorage: objectStorage || system.repository.objectStorage,\n        indexFile: indexFile || system.repository.indexFile,\n        refStorage: refStorage || system.repository.refStorage,\n      },\n    },\n  };\n};\n\n/**\n * Utility function to return system with components\n * overridden with provided arguments. Use for returning\n * final system state after successful command execution.\n */\nexport const successState = (\n  system: SandboxState,\n  fileSystem?: FileSystem | null,\n  objectStorage?: ObjectStorage | null,\n  indexFile?: IndexFile | null,\n  head?: GitHead | null,\n  refStorage?: RefStorage | null\n): { system: SandboxState; success: boolean } => {\n  return {\n    success: true,\n    system: {\n      fileSystem: fileSystem || system.fileSystem,\n      repository: {\n        head: head || system.repository.head,\n        objectStorage: objectStorage || system.repository.objectStorage,\n        indexFile: indexFile || system.repository.indexFile,\n        refStorage: refStorage || system.repository.refStorage,\n      },\n    },\n  };\n};\n","import FileSystem, { FileSystemPath } from '../../file-system';\nimport {\n  Command,\n  CommandOptions,\n  CommandOptionsProfile,\n  CommandOptionValues,\n} from '../types';\nimport {\n  getPathString,\n  isPrefix,\n  parsePathString,\n} from '../../utils/path-utils';\nimport { SandboxState } from '../../types';\nimport { errorState, successState } from '../utils';\nimport { Apocalypse } from '../../utils/errors';\n\ninterface CpOptions extends CommandOptionsProfile {\n  recursive: 'boolean';\n}\n\nconst cpOptions: CommandOptions<CpOptions> = {\n  recursive: {\n    shortLetter: 'r',\n    description: 'copy directories recursively',\n    valueType: 'boolean',\n  },\n};\n\n/**\n * Validate that the source path is a valid path to copy from.\n * Pass `noDirectory: true` if source is not allowed to be directory.\n */\nconst validateSource = (\n  fs: FileSystem,\n  srcPath: FileSystemPath,\n  print: (text: string) => void,\n  noDirectory?: boolean\n): boolean => {\n  const srcPathDepth = fs.getPathDepth(srcPath);\n  if (srcPathDepth !== 1 && srcPathDepth !== 2) {\n    print(`${getPathString(srcPath)}: invalid path`);\n    return false;\n  } else if (srcPathDepth === 1 && noDirectory) {\n    print(`-r not provided: omitting directory'${getPathString(srcPath)}'`);\n    return false;\n  } else return true;\n};\n\n/**\n * Validate that the destination is a valid path to copy to.\n * Pass `ensureDir: true` if destination must be directory.\n */\nconst validateDest = (\n  fs: FileSystem,\n  destPath: FileSystemPath,\n  print: (text: string) => void,\n  ensureDir?: boolean\n): boolean => {\n  const destPathDepth = fs.getPathDepth(destPath);\n  if (destPathDepth >= 4) {\n    // Parent is leaf or does not exist\n    print(`target '${getPathString(destPath)}' is not a directory`);\n    return false;\n  } else if (ensureDir && destPathDepth >= 2) {\n    // `ensureDir = true` but path is not a directory\n    print(`target '${getPathString(destPath)}' is not a directory`);\n    return false;\n  } else return true;\n};\n\n/**\n * Handler for the `cp` command.\n * Copy provided source items to the destination path.\n */\nconst copyItems = (\n  system: SandboxState,\n  paths: FileSystemPath[],\n  opts: CommandOptionValues<CpOptions>,\n  print: (text: string) => void\n) => {\n  // `cp` takes atleast 2 arguments\n  if (paths.length < 2) {\n    print(`insufficient arguments`);\n    return errorState(system);\n  }\n\n  const srcPaths = paths.slice(0, -1);\n  const destPath = paths[paths.length - 1];\n  const multiSrc = srcPaths.length > 1;\n  const recursive = !!opts.recursive;\n\n  // Validate the destination path - must be directory if multiple sources are provided\n  const destValid = validateDest(system.fileSystem, destPath, print, multiSrc);\n  if (!destValid) return errorState(system);\n\n  let currentFS = system.fileSystem;\n  for (const srcPath of srcPaths) {\n    // Validate source path - directories allowed only if recursive flag passed\n    const srcValid = validateSource(currentFS, srcPath, print, !recursive);\n    if (!srcValid) return errorState(system, currentFS);\n    const srcItemName = srcPath[srcPath.length - 1];\n\n    // Create the full destination path\n    const destNode = currentFS.get(destPath);\n    if (!destNode) throw new Apocalypse(); // Item copy-renaming not implemented\n    let fullDest = FileSystem.isFile(destNode)\n      ? destPath\n      : [...destPath, srcItemName];\n\n    // Ensure destination is not subdir of source\n    if (isPrefix(fullDest, srcPath)) {\n      const destPathStr = getPathString(fullDest);\n      const srcPathStr = getPathString(srcPath);\n      if (fullDest.length === srcPath.length)\n        print(`'${srcPathStr}' and '${destPathStr}' are the same file`);\n      else\n        print(\n          `cannot copy a directory, '${srcPathStr}', into itself, '${destPathStr}'`\n        );\n      return errorState(system, currentFS);\n    }\n\n    const newFS = currentFS.move(srcPath, fullDest, true);\n    currentFS = newFS;\n  }\n\n  return successState(system, currentFS);\n};\n\n/**\n * Copies files/directories at specified source paths\n * to the specified destination path. Similar to UNIX `cp`.\n */\nconst cpCommand: Command<CpOptions> = {\n  name: 'cp',\n  options: cpOptions,\n\n  execute: (system, print, opts, args) => {\n    const paths = args.map(parsePathString);\n    return copyItems(system, paths, opts, print);\n  },\n};\n\nexport default cpCommand;\n","import { Command, CommandOptions, CommandOptionsProfile } from '../types';\nimport {\n  getParentPath,\n  getPathString,\n  parsePathString,\n} from '../../utils/path-utils';\nimport { errorState, successState } from '../utils';\nimport FileSystem, { FileSystemPath } from '../../file-system';\n\ninterface CreateOptions extends CommandOptionsProfile {}\n\nconst createOptions: CommandOptions<CreateOptions> = {};\n\n/**\n * Execute a single `create` operation on the filesystem.\n */\nconst createFile = (\n  fs: FileSystem,\n  print: (text: string) => void,\n  path: FileSystemPath\n): FileSystem | void => {\n  const pathString = getPathString(path);\n  if (path.length === 0) return print(`\"${pathString}\": invalid path`);\n  const parentPath = getParentPath(path);\n  if (!fs.get(parentPath)) return print(`\"${pathString}\": invalid path`);\n  if (fs.get(path)) return print(`\"${pathString}\": already exists`);\n  return fs.create(path, 'file');\n};\n\n/**\n * Create new files at specified paths.\n */\nconst createCommand: Command<CreateOptions> = {\n  name: 'create',\n  options: createOptions,\n\n  execute: (system, print, _opts, args) => {\n    // Parse arguments into paths.\n    const paths = args.map(parsePathString);\n    if (paths.length === 0) {\n      print('no file paths provided');\n      return errorState(system);\n    }\n\n    // Iterate through arguments and execute each create op.\n    let currentFS = system.fileSystem;\n    for (const path of paths) {\n      const newFS = createFile(currentFS, print, path);\n      if (!newFS) return errorState(system, currentFS);\n      currentFS = newFS;\n    }\n\n    return successState(system, currentFS);\n  },\n};\n\nexport default createCommand;\n","import { Command, CommandOptions, CommandOptionsProfile } from '../types';\nimport { getPathString, parsePathString } from '../../utils/path-utils';\nimport { errorState, successState } from '../utils';\n\ninterface EditOptions extends CommandOptionsProfile {}\n\nconst editOptions: CommandOptions<EditOptions> = {};\n\n/**\n * Bumps the file version of files at specified paths.\n */\nconst editCommand: Command<EditOptions> = {\n  name: 'edit',\n  options: editOptions,\n\n  execute: (system, print, _opts, args) => {\n    const paths = args.map(parsePathString);\n    if (paths.length === 0) {\n      // No paths provided\n      print('missing path operand');\n      return errorState(system);\n    }\n\n    let currentFS = system.fileSystem;\n    for (const path of paths) {\n      // Check if the node exists\n      const nodeDepth = currentFS.getPathDepth(path);\n      if (nodeDepth !== 2) {\n        print(`'${getPathString(path)}': invalid path`);\n        return errorState(system, currentFS);\n      }\n      // Bump file at current path\n      const newFS = currentFS.bumpFileVersion(path);\n      currentFS = newFS;\n    }\n\n    return successState(system, currentFS);\n  },\n};\n\nexport default editCommand;\n","import { Command, CommandOptions, CommandOptionsProfile } from '../types';\nimport { getPathString, parsePathString } from '../../utils/path-utils';\nimport { errorState, successState } from '../utils';\n\ninterface MkdirOptions extends CommandOptionsProfile {}\n\nconst mkdirOptions: CommandOptions<MkdirOptions> = {};\n\n/**\n * Creates new empty directory at specified paths, similar to UNIX `mkdir`\n */\nconst mkdirCommand: Command<MkdirOptions> = {\n  name: 'mkdir',\n  options: mkdirOptions,\n\n  execute: (system, print, _opts, args) => {\n    const paths = args.map(parsePathString);\n    if (paths.length === 0) {\n      // No paths provided\n      print('missing path operand');\n      return errorState(system);\n    }\n\n    let currentFS = system.fileSystem;\n    for (const path of paths) {\n      // Check if path is valid\n      const pathDepth = currentFS.getPathDepth(path);\n      if (pathDepth !== 3) {\n        print(`'${getPathString(path)}': invalid path`);\n        return errorState(system, currentFS);\n      }\n      // Execute `mkdir` for this path\n      const newFS = currentFS.create(path, 'directory');\n      currentFS = newFS;\n    }\n\n    return successState(system, currentFS);\n  },\n};\n\nexport default mkdirCommand;\n","import FileSystem, { FileSystemPath } from '../../file-system';\nimport {\n  Command,\n  CommandOptions,\n  CommandOptionsProfile,\n  CommandOptionValues,\n} from '../types';\nimport {\n  getPathString,\n  isPrefix,\n  parsePathString,\n} from '../../utils/path-utils';\nimport { SandboxState } from '../../types';\nimport { errorState, successState } from '../utils';\nimport { Apocalypse } from '../../utils/errors';\n\ninterface MvOptions extends CommandOptionsProfile {\n  recursive: 'boolean';\n}\n\nconst mvOptions: CommandOptions<MvOptions> = {\n  recursive: {\n    shortLetter: 'r',\n    description: 'copy directories recursively',\n    valueType: 'boolean',\n  },\n};\n\n/**\n * Validate that the source path is a valid path to move from.\n * Pass `noDirectory: true` if source is not allowed to be directory.\n */\nconst validateSource = (\n  fs: FileSystem,\n  srcPath: FileSystemPath,\n  print: (text: string) => void,\n  noDirectory?: boolean\n): boolean => {\n  const srcPathDepth = fs.getPathDepth(srcPath);\n  if (srcPathDepth !== 1 && srcPathDepth !== 2) {\n    print(`${getPathString(srcPath)}: invalid path`);\n    return false;\n  } else if (srcPathDepth === 1 && noDirectory) {\n    print(`-r not provided: omitting directory'${getPathString(srcPath)}'`);\n    return false;\n  } else return true;\n};\n\n/**\n * Validate that the destination is a valid path to move to.\n * Pass `ensureDir: true` if destination must be directory.\n */\nconst validateDest = (\n  fs: FileSystem,\n  destPath: FileSystemPath,\n  print: (text: string) => void,\n  ensureDir?: boolean\n): boolean => {\n  const destPathDepth = fs.getPathDepth(destPath);\n  if (destPathDepth >= 4) {\n    // Parent is leaf or does not exist\n    print(`target '${getPathString(destPath)}' is not a directory`);\n    return false;\n  } else if (ensureDir && destPathDepth >= 2) {\n    // `ensureDir = true` but path is not a directory\n    print(`target '${getPathString(destPath)}' is not a directory`);\n    return false;\n  } else return true;\n};\n\n/**\n * Handler for the `mv` command.\n * Move provided source items to the destination path.\n */\nconst moveItems = (\n  system: SandboxState,\n  paths: FileSystemPath[],\n  opts: CommandOptionValues<MvOptions>,\n  print: (text: string) => void\n) => {\n  // `mv` takes atleast 2 arguments\n  if (paths.length < 2) {\n    print(`insufficient arguments`);\n    return errorState(system);\n  }\n\n  const srcPaths = paths.slice(0, -1);\n  const destPath = paths[paths.length - 1];\n  const multiSrc = srcPaths.length > 1;\n  const recursive = !!opts.recursive;\n\n  // Validate the destination path - must be directory if multiple sources are provided\n  const destValid = validateDest(system.fileSystem, destPath, print, multiSrc);\n  if (!destValid) return errorState(system);\n\n  let currentFS = system.fileSystem;\n  for (const srcPath of srcPaths) {\n    // Validate source path - directories allowed only if recursive flag passed\n    const srcValid = validateSource(currentFS, srcPath, print, !recursive);\n    if (!srcValid) return errorState(system, currentFS);\n    const srcItemName = srcPath[srcPath.length - 1];\n\n    // Create the full destination path\n    const destNode = currentFS.get(destPath);\n    if (!destNode) throw new Apocalypse(); // (Item-renaming not implemented)\n    let fullDest = FileSystem.isFile(destNode)\n      ? destPath\n      : [...destPath, srcItemName];\n\n    // Ensure destination is not subdir of source\n    if (isPrefix(fullDest, srcPath)) {\n      const destPathStr = getPathString(fullDest);\n      const srcPathStr = getPathString(srcPath);\n      if (fullDest.length === srcPath.length)\n        print(`'${srcPathStr}' and '${destPathStr}' are the same file`);\n      else\n        print(\n          `cannot move '${srcPathStr}' to a subdirectory of itself, '${destPathStr}'`\n        );\n      return errorState(system, currentFS);\n    }\n\n    const newFS = currentFS.move(srcPath, fullDest);\n    currentFS = newFS;\n  }\n\n  return successState(system, currentFS);\n};\n\n/**\n * Moves files/directories at specified source paths\n * to the specified destination path. Similar to UNIX `mv`.\n */\nconst mvCommand: Command<MvOptions> = {\n  name: 'mv',\n  options: mvOptions,\n\n  execute: (system, print, opts, args) => {\n    const paths = args.map(parsePathString);\n    return moveItems(system, paths, opts, print);\n  },\n};\n\nexport default mvCommand;\n","import { Command, CommandOptions, CommandOptionsProfile } from '../types';\nimport { parsePathString } from '../../utils/path-utils';\nimport { errorState, successState } from '../utils';\nimport FileSystem from '../../file-system';\n\ninterface RmOptions extends CommandOptionsProfile {\n  recursive: 'boolean';\n}\n\nconst rmOptions: CommandOptions<RmOptions> = {\n  recursive: {\n    shortLetter: 'r',\n    description: 'delete recursively',\n    valueType: 'boolean',\n  },\n};\n\n/**\n * Delete files or directories at specified paths, similar to UNIX `rm`.\n */\nconst rmCommand: Command<RmOptions> = {\n  name: 'rm',\n  options: rmOptions,\n\n  execute: (system, print, opts, args) => {\n    const paths = args.map(parsePathString);\n    if (paths.length === 0) {\n      print('missing file operand');\n      return errorState(system);\n    }\n\n    let currentFS = system.fileSystem;\n    for (const path of paths) {\n      const node = currentFS.get(path);\n      if (!node) {\n        // Path does not exist\n        print(`'${path}': no such file or directory`);\n        return errorState(system, currentFS);\n      } else if (FileSystem.isDirectory(node) && !opts.recursive) {\n        // Path is directory, and `recursive` not provided\n        print(`'${path}': is a directory`);\n        return errorState(system, currentFS);\n      }\n\n      // Remove item and update FS\n      const newFS = currentFS.delete(path);\n      currentFS = newFS;\n    }\n\n    return successState(system, currentFS);\n  },\n};\n\nexport default rmCommand;\n","import IndexFile from '../../git-repository/index-file';\nimport { parsePathString } from '../../utils/path-utils';\nimport { Command, CommandOptions, CommandOptionsProfile } from '../types';\nimport { errorState, successState } from '../utils';\n\ninterface GitAddOptions extends CommandOptionsProfile {}\n\nconst gitAddOptions: CommandOptions<GitAddOptions> = {};\n\n/**\n * Adds a list of paths to the index. For paths leading to directories,\n * adds all files inside the directory to index.\n */\nconst gitAddCommand: Command<GitAddOptions> = {\n  name: 'git-add',\n  options: gitAddOptions,\n\n  execute: (system, print, _opts, args) => {\n    const { fileSystem } = system;\n    const { objectStorage, indexFile } = system.repository;\n\n    const paths = args.map(parsePathString);\n    if (paths.length === 0) {\n      print('missing path operand');\n      return errorState(system);\n    }\n\n    let currentIndex = indexFile;\n    let currentObjectStorage = objectStorage;\n    for (const path of paths) {\n      const fsItem = fileSystem.get(path);\n      const indexSection = indexFile.getPathSection(path);\n\n      if (!fsItem) {\n        // No file/directory exists at specified path\n        // 1. If it does not exist in index file either, path is invalid\n        if (indexSection.start === indexSection.end) {\n          print(`pathspec '${path}' did not match any files`);\n          return errorState(system, null, currentObjectStorage, currentIndex);\n        }\n        // 2. Else, path corresponds to deleted items\n        const newIndex = currentIndex.overwriteSection(path, new IndexFile());\n        currentIndex = newIndex;\n      } else {\n        // File/directory exists: create subindex and overwrite main index\n        const {\n          storage: newStorage,\n          indexFile: subIndex,\n        } = IndexFile.fromFileTree(fsItem, currentObjectStorage, path);\n        const newIndex = currentIndex.overwriteSection(path, subIndex);\n        if (!newIndex) throw new Error(`This shouldn't happen.`);\n        currentIndex = newIndex;\n        currentObjectStorage = newStorage;\n      }\n    }\n\n    return successState(system, null, currentObjectStorage, currentIndex);\n  },\n};\n\nexport default gitAddCommand;\n","import FileSystem from '../../file-system';\nimport GitHead from '../../git-repository/head';\nimport IndexFile from '../../git-repository/index-file';\nimport { GitObjectAddress } from '../../git-repository/object-storage/types';\nimport { serializeGitTree } from '../../git-repository/object-storage/utils';\nimport { Apocalypse } from '../../utils/errors';\nimport { Command, CommandOptions, CommandOptionsProfile } from '../types';\nimport { errorState, successState } from '../utils';\n\ninterface GitCheckoutOptions extends CommandOptionsProfile {}\n\nconst gitCheckoutOptions: CommandOptions<GitCheckoutOptions> = {};\n\n/**\n * Parse the arguments to get target commit\n */\nconst parseArgs = (\n  args: string[],\n  print: (text: string) => void\n): GitObjectAddress | null => {\n  if (args.length === 0) {\n    // No arguments provided\n    print('missing target commit');\n    return null;\n  } else if (args.length >= 2) {\n    // Too many arguments provided\n    print('too many operands');\n    return null;\n  }\n\n  return args[0];\n};\n\n/**\n * Given the commit address, checks out a specific commit.\n * Updates file system and index file to commit snapshot.\n */\nconst gitCheckoutCommand: Command<GitCheckoutOptions> = {\n  name: 'git-checkout',\n  options: gitCheckoutOptions,\n\n  execute: (system, print, _opts, args) => {\n    const { objectStorage } = system.repository;\n\n    // Parse arguments to get commit address\n    const commitHash = parseArgs(args, print);\n    if (!commitHash) return errorState(system);\n\n    // Get commit object from storage\n    const commitObject = objectStorage.read(commitHash);\n    if (!commitObject || commitObject.type !== 'commit') {\n      print(`'${commitHash}': invalid commit address`);\n      return errorState(system);\n    }\n\n    // Get corresponding Git work tree and serialize it\n    const gitTreeAddress = commitObject.workTree;\n    const gitWorkTree = objectStorage.read(gitTreeAddress);\n    if (!gitWorkTree || gitWorkTree.type !== 'tree')\n      throw new Apocalypse('Commit does not point to valid work tree!');\n    const serializedTree = serializeGitTree(gitWorkTree, objectStorage);\n\n    // Create file system from work tree\n    const newFileSystem = new FileSystem(\n      serializedTree.convert((gitBlob) => gitBlob.fileData)\n    );\n\n    // Create index file from work tree\n    const newIndexFile = IndexFile.fromGitTree(objectStorage, gitWorkTree);\n\n    // Update HEAD\n    const newHead: GitHead = system.repository.head.detachTo(commitHash);\n\n    // Return new system state\n    print(`HEAD is now at ${commitHash.slice(-7)}`);\n    return successState(system, newFileSystem, null, newIndexFile, newHead);\n  },\n};\n\nexport default gitCheckoutCommand;\n","import { Command, CommandOptions, CommandOptionsProfile } from '../types';\nimport { IndexTree } from '../../git-repository/index-file/create-index-tree';\nimport {\n  GitObjectAddress,\n  GitTree,\n} from '../../git-repository/object-storage/types';\nimport Tree from '../../utils/tree';\nimport { errorState, successState } from '../utils';\nimport ObjectStorage from '../../git-repository/object-storage';\n\ninterface GitCommitOptions extends CommandOptionsProfile {\n  message: 'single';\n}\n\nconst gitCommitOptions: CommandOptions<GitCommitOptions> = {\n  message: {\n    shortLetter: 'm',\n    description: 'commit message',\n    valueType: 'single',\n  },\n};\n\n/**\n * Given an index tree, creates a Git work tree, registers it\n * in object storage and returns the hash address.\n */\nconst createWorkTreeFromIndex = (\n  indexTree: IndexTree,\n  objectStorage: ObjectStorage\n): { storage: ObjectStorage; hash: GitObjectAddress } => {\n  const children = [...indexTree._tree.entries()];\n  const treeItems = new Map<string, GitObjectAddress>();\n\n  let currentStorage = objectStorage;\n  for (const child of children) {\n    if (Tree.isLeafNode(child[1])) {\n      // Leaf node: directly add to work tree\n      treeItems.set(child[0], child[1].objectHash);\n    } else {\n      // Sub-tree: recursively create subtree and add to main tree\n      const { storage: newStorage, hash } = createWorkTreeFromIndex(\n        new Tree(child[1]),\n        objectStorage\n      );\n      treeItems.set(child[0], hash);\n      currentStorage = newStorage;\n    }\n  }\n\n  // Register tree to object storage and return hash\n  const gitTree: GitTree = { type: 'tree', items: treeItems };\n  return currentStorage.write(gitTree);\n};\n\n/**\n * Commits the current index snapshot to the repository,\n * updating HEAD to the new commit. Fails if the index snapshot\n * does not resolve to a valid work tree.\n */\nconst gitCommitCommand: Command<GitCommitOptions> = {\n  name: 'git-commit',\n  options: gitCommitOptions,\n\n  execute: (system, print, opts, _args) => {\n    // Parse options to get commit message\n    if (!opts.message) {\n      print('missing commit message');\n      return errorState(system);\n    }\n    const commitMessage = opts.message;\n    const { indexFile, objectStorage, refStorage } = system.repository;\n\n    try {\n      // Create Git work tree from current index snapshot\n      const indexTree = indexFile.toTree();\n      const { storage: tempStorage, hash: treeHash } = createWorkTreeFromIndex(\n        indexTree,\n        objectStorage\n      );\n\n      // Create new commit object\n      const parentCommit = system.repository.head.getTargetCommit(refStorage);\n      const { storage, hash: commitHash } = tempStorage.write({\n        type: 'commit',\n        timestamp: new Date(),\n        workTree: treeHash,\n        message: commitMessage,\n        parent: parentCommit,\n      });\n\n      // Update HEAD and refs\n      const {\n        head: newHead,\n        refStorage: newRefStorage,\n      } = system.repository.head.advanceTo(refStorage, commitHash);\n\n      return successState(system, null, storage, null, newHead, newRefStorage);\n    } catch {\n      // Point of error: call to `createIndexTree`\n      print(`invalid index tree`);\n      return errorState(system);\n    }\n  },\n};\n\nexport default gitCommitCommand;\n","import FileSystem from '../../file-system';\nimport IndexFile from '../../git-repository/index-file';\nimport { serializeGitTree } from '../../git-repository/object-storage/utils';\nimport {\n  Command,\n  CommandOptions,\n  CommandOptionsProfile,\n  CommandOptionValues,\n} from '../types';\nimport { errorState, successState } from '../utils';\n\ninterface GitResetOptions extends CommandOptionsProfile {\n  soft: 'boolean';\n  mixed: 'boolean';\n  hard: 'boolean';\n}\n\nconst gitResetOptions: CommandOptions<GitResetOptions> = {\n  soft: {\n    valueType: 'boolean',\n    description: 'does not touch index file or working tree',\n  },\n  mixed: {\n    valueType: 'boolean',\n    description: 'resets index but not working tree',\n  },\n  hard: {\n    valueType: 'boolean',\n    description: 'resets index and working tree',\n  },\n};\n\n/**\n * Parse arguments to get target commit.\n */\nconst parseArgs = (args: string[], print: (text: string) => void) => {\n  if (args.length === 0) print('missing target commit');\n  else if (args.length >= 2) print('too many operands');\n  else return args[0];\n};\n\n/**\n * Parse options to get the reset mode (soft/mixed/hard).\n */\nconst getResetMode = (opts: CommandOptionValues<GitResetOptions>) => {\n  if (opts.soft) return 'soft';\n  else if (opts.mixed) return 'mixed';\n  else if (opts.hard) return 'hard';\n  else return 'mixed';\n};\n\n/**\n * Resets the current HEAD and head ref to the target commit provided.\n * Depending on reset mode, also resets the index file and file system.\n *\n * Returns success status of the operation.\n */\nconst gitResetCommand: Command<GitResetOptions> = {\n  name: 'git-reset',\n  options: gitResetOptions,\n\n  execute: (system, print, opts, args) => {\n    const { objectStorage, refStorage, head } = system.repository;\n\n    // Parse to get target commit and reset mode\n    const targetCommitHash = parseArgs(args, print);\n    if (!targetCommitHash) return errorState(system);\n    const resetMode = getResetMode(opts);\n\n    // Get the commit and work tree objects\n    const commit = objectStorage.read(targetCommitHash);\n    if (!commit || commit.type !== 'commit') {\n      print(`'${targetCommitHash.slice(-7)}': invalid commit address`);\n      return errorState(system);\n    }\n    const tree = objectStorage.read(commit.workTree);\n    if (!tree || tree.type !== 'tree')\n      throw new Error('Inconsistent object storage');\n\n    // Update HEAD to the target commit\n    const { head: newHead, refStorage: newRefStorage } = head.advanceTo(\n      refStorage,\n      targetCommitHash\n    );\n    if (resetMode === 'soft')\n      return successState(system, null, null, null, newHead, newRefStorage);\n\n    // Mixed/Hard: reset index file\n    const newIndexFile = IndexFile.fromGitTree(objectStorage, tree);\n    if (resetMode === 'mixed')\n      return successState(\n        system,\n        null,\n        null,\n        newIndexFile,\n        newHead,\n        newRefStorage\n      );\n\n    // Hard: reset file system\n    const serializedTree = serializeGitTree(tree, objectStorage);\n    const newFileSystem = new FileSystem(\n      serializedTree.convert((gb) => gb.fileData)\n    );\n    return successState(\n      system,\n      newFileSystem,\n      null,\n      newIndexFile,\n      newHead,\n      newRefStorage\n    );\n  },\n};\n\nexport default gitResetCommand;\n","import yargsParse from 'yargs-parser';\nimport {\n  Command,\n  CommandOptions,\n  CommandOptionsProfile,\n} from '../operations/types';\n\n/**\n * Stores the available executables, like\n * the bash PATH variable.\n */\nexport type BinPath = { [k: string]: Command<any> };\n\n/**\n * The result of parsing some valid input string\n */\nexport type ParsedInput = {\n  command: string;\n  args: string[];\n  opts: { [optName: string]: boolean | string };\n};\n\n/**\n * Parses user input from the terminal into the command run,\n * along with options and arguments passed.\n */\nexport default class Parser {\n  private binPath: BinPath;\n\n  /**\n   * Initializes the parser, loading the commands\n   * on provided path into the parser.\n   */\n  constructor(path: BinPath) {\n    this.binPath = path || {};\n  }\n\n  /**\n   * Parses a terminal input to get the command run, its options and arguments passed.\n   * Returns `null` for invalid input or if no matching command is found on path.\n   */\n  parse = (input: string): ParsedInput | null => {\n    if (input.trim().length === 0) return null;\n\n    // Find the command run, by testing each command name against start of input\n    const commandName = Object.keys(this.binPath).find((cmdName) => {\n      const cmdNamePrefix = cmdName + ' ';\n      return input.indexOf(cmdNamePrefix) === 0;\n    });\n    if (!commandName) return null;\n\n    // Parse the opts-args part of input using the command's option config\n    const argSubstring = input.slice(commandName.length + 1);\n    const commandOptions = this.binPath[commandName].options;\n    const yargsOpts = this.createYargsOptions(commandOptions);\n    const parsed = yargsParse(argSubstring, yargsOpts);\n\n    const { _: args, '--': _o, ...opts } = parsed;\n    return { command: commandName, args, opts };\n  };\n\n  /**\n   * Create yargs-specific `opts` object for parsing\n   */\n  private createYargsOptions = <T extends CommandOptionsProfile>(\n    cmdOptions: CommandOptions<T>\n  ): yargsParse.Options => {\n    const yOpts = {\n      string: [] as string[],\n      boolean: [] as string[],\n      alias: {} as { [key: string]: string | string[] },\n    };\n\n    Object.keys(cmdOptions).forEach((optionName) => {\n      const option = cmdOptions[optionName];\n      if (option.shortLetter) yOpts.alias[optionName] = option.shortLetter;\n      if (option.valueType === 'boolean') yOpts.boolean.push(optionName);\n      if (option.valueType === 'single') yOpts.string.push(optionName);\n    });\n\n    return yOpts;\n  };\n}\n","import CpCommand from '../operations/file-system/cp';\nimport CreateCommand from '../operations/file-system/create';\nimport EditCommand from '../operations/file-system/edit';\nimport MkdirCommand from '../operations/file-system/mkdir';\nimport MvCommand from '../operations/file-system/mv';\nimport RmCommand from '../operations/file-system/rm';\nimport GitAddCommand from '../operations/git-repository/add';\nimport GitCheckoutCommand from '../operations/git-repository/checkout';\nimport GitCommitCommand from '../operations/git-repository/commit';\nimport GitResetCommand from '../operations/git-repository/reset';\nimport { SandboxState } from '../types';\nimport Parser, { BinPath } from './parser';\n\ntype ExecResult = {\n  system: SandboxState;\n  success: boolean;\n};\n\nconst PATH: BinPath = {\n  create: CreateCommand,\n  edit: EditCommand,\n  mkdir: MkdirCommand,\n  rm: RmCommand,\n  cp: CpCommand,\n  mv: MvCommand,\n\n  'git add': GitAddCommand,\n  'git checkout': GitCheckoutCommand,\n  'git commit': GitCommitCommand,\n  'git reset': GitResetCommand,\n};\n\nclass Terminal {\n  private parser: Parser = new Parser(PATH);\n\n  /**\n   * Executes the user input on the system provided.\n   * Returns success or failure status of command.\n   */\n  execute = (\n    input: string,\n    system: SandboxState,\n    print: (text: string) => void\n  ): ExecResult => {\n    const parsed = this.parser.parse(input);\n    if (!parsed) return { system, success: false };\n\n    const commandUsed = PATH[parsed.command];\n    if (!commandUsed) return { system, success: false };\n\n    return commandUsed.execute(system, print, parsed.opts, parsed.args);\n  };\n}\n\nexport default Terminal;\n","import { List } from 'immutable';\n\ntype TerminalLine = {\n  text: string;\n  prompt?: string;\n};\n\nexport type TerminalHistory = List<TerminalLine>;\n\n/**\n * Creates a blank terminal data holder.\n */\nexport const startTerminal = (): TerminalHistory => List();\n\n/**\n * Pushes a line of output into the terminal, and\n * returns the new terminal data holder.\n */\nexport const pushOutput = (\n  terminalLines: TerminalHistory,\n  text: string\n): TerminalHistory => terminalLines.push({ text });\n\n/**\n * Pushes a line of user input into the terminal, and\n * returns the new terminal data holder.\n */\nexport const pushInput = (\n  terminalLines: TerminalHistory,\n  text: string,\n  prompt: string\n): TerminalHistory => terminalLines.push({ text, prompt });\n","import clsx from 'classnames';\n\ntype Props = {\n  text: string;\n  prompt?: string;\n};\n\n/**\n * A single fixed-height row, intended for a single line\n * of terminal input or output.\n */\nconst TerminalRow = (props: Props) => {\n  const classes = clsx('terminal-row', { prompt: !!props.prompt });\n\n  return (\n    <div className={classes}>\n      {props.prompt && (\n        <span className='terminal-row-prompt'>{props.prompt}</span>\n      )}\n      {props.text}\n    </div>\n  );\n};\n\nexport default TerminalRow;\n","import * as React from 'react';\nimport { TerminalHistory } from './terminal';\nimport TerminalRow from './terminal-row';\n\ntype Props = {\n  data: TerminalHistory;\n};\n\nexport const TerminalData = (props: Props) => {\n  const containerRef = React.useRef<HTMLDivElement | null>(null);\n\n  // Scroll to bottom when history changes\n  React.useEffect(() => {\n    const container = containerRef.current;\n    if (!container) return;\n    container.scrollTop = container.scrollHeight;\n  }, [props.data]);\n\n  return (\n    <div className='terminal-data' ref={(r) => (containerRef.current = r)}>\n      {Array.from({ length: props.data.size }).map((_, idx) => {\n        const dataLine = props.data.get(idx);\n        if (!dataLine) throw new Error(`This shouldn't happen.`);\n        return (\n          <TerminalRow\n            key={idx}\n            text={dataLine.text}\n            prompt={dataLine.prompt}\n          />\n        );\n      })}\n    </div>\n  );\n};\n","import * as React from 'react';\n\ntype Props = {\n  onInput: (input: string) => void;\n};\n\nexport const TerminalInput = (props: Props) => {\n  const [input, setInput] = React.useState('');\n  const { onInput } = props;\n\n  const changeInput = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setInput(event.target.value);\n  };\n\n  // Set up event listener for Enter key\n  React.useEffect(() => {\n    const handler = (event: KeyboardEvent) => {\n      if (event.key !== 'Enter') return;\n      const trimmedInput = input.trim();\n      if (trimmedInput === '') return;\n      setInput('');\n      onInput(trimmedInput);\n    };\n    document.addEventListener('keyup', handler);\n    return () => document.removeEventListener('keyup', handler);\n  }, [input, onInput]);\n\n  return (\n    <div className='terminal-input__wrapper'>\n      <div className='terminal-input'>\n        <span className='prompt'>{'>'}</span>\n        <input value={input} onChange={changeInput} className='input' />\n      </div>\n    </div>\n  );\n};\n","import * as React from 'react';\nimport Terminal from '../../../simulator/terminal';\nimport { SandboxContext } from '../../mainframe/providers/sandbox-provider';\nimport Pane from '../pane';\nimport { pushInput, pushOutput, startTerminal } from './terminal';\nimport { TerminalData } from './terminal-data';\nimport { TerminalInput } from './terminal-input';\n\nconst terminalObj = new Terminal();\n\nconst TerminalPane = () => {\n  const sandboxManager = React.useContext(SandboxContext);\n  const terminalRef = React.useRef(terminalObj);\n  const [terminalHistory, setTerminalHistory] = React.useState(startTerminal());\n\n  /**\n   * Execute the user input and add it to the terminal history\n   */\n  const executeInput = (input: string) => {\n    const terminal = terminalRef.current;\n    if (!sandboxManager.value) throw new Error(`command executed w/o sandbox`);\n    setTerminalHistory((oldHistory) => pushInput(oldHistory, input, '>'));\n    if (input === 'clear') return setTerminalHistory(startTerminal());\n\n    const { system: newSystem } = terminal.execute(\n      input,\n      sandboxManager.value,\n      (text) => setTerminalHistory((h) => pushOutput(h, text))\n    );\n\n    sandboxManager.setSandbox(newSystem);\n  };\n\n  return (\n    <Pane className='terminal-pane'>\n      <div className='terminal-container'>\n        <TerminalData data={terminalHistory} />\n        <TerminalInput onInput={executeInput} />\n      </div>\n    </Pane>\n  );\n};\n\nexport default TerminalPane;\n","import { MosaicParent } from 'react-mosaic-component';\n\n/**\n * A layout similar to VS Code:\n * - Full-height file manager on left\n * - Bottom-half terminal on right\n * - Two horizontal-split panes in top-right space\n */\nexport const vsCodeLayout: MosaicParent<string> = {\n  direction: 'row',\n  splitPercentage: 25,\n  first: 'file-system',\n  second: {\n    direction: 'column',\n    splitPercentage: 60,\n    first: {\n      direction: 'row',\n      splitPercentage: 40,\n      first: 'index-file-view',\n      second: 'object-storage-view',\n    },\n    second: 'terminal',\n  },\n};\n\n/**\n * Ultra-multitasking view:\n * - Terminal at top-right\n * - File manager at bottom-right\n * and four panes on left\n */\nexport const multitaskerLayout: MosaicParent<string> = {\n  direction: 'row',\n  splitPercentage: 75,\n  first: {\n    direction: 'column',\n    splitPercentage: 50,\n    first: {\n      direction: 'row',\n      first: 'index-file-view',\n      second: 'object-storage-view',\n    },\n    second: {\n      direction: 'row',\n      first: 'staging-area',\n      second: 'repository-view',\n    },\n  },\n  second: {\n    direction: 'column',\n    splitPercentage: 50,\n    first: 'terminal',\n    second: 'file-system',\n  },\n};\n","import * as React from 'react';\nimport { Mosaic } from 'react-mosaic-component';\nimport FileSystemPane from '../panes/files-manager';\nimport { IndexFileView } from '../panes/index-file-view';\nimport ObjectStorageView from '../panes/object-storage-view';\nimport RepositoryViewerPane from '../panes/repository-viewer';\nimport StagingAreaPane from '../panes/staging-area';\nimport TerminalPane from '../panes/terminal';\nimport { multitaskerLayout } from './layouts';\nimport { SandboxContext } from './providers/sandbox-provider';\n\nconst ELEMENT_MAP: { [key: string]: JSX.Element } = {\n  'file-system': <FileSystemPane />,\n  'staging-area': <StagingAreaPane />,\n  'repository-view': <RepositoryViewerPane />,\n  'object-storage-view': <ObjectStorageView />,\n  'index-file-view': <IndexFileView />,\n  terminal: <TerminalPane />,\n};\n\nexport const Mainframe = () => {\n  const sandboxManager = React.useContext(SandboxContext);\n\n  if (!sandboxManager.value) return null;\n\n  return (\n    <Mosaic<string>\n      className={'pane-mosaic'}\n      renderTile={(id) => ELEMENT_MAP[id]}\n      initialValue={multitaskerLayout}\n    />\n  );\n};\n","import './App.css';\nimport { SandboxProvider } from './app/mainframe/providers/sandbox-provider';\nimport { Mainframe } from './app/mainframe';\n\nfunction App() {\n  return (\n    <div className='App'>\n      <SandboxProvider>\n        <Mainframe />\n      </SandboxProvider>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}